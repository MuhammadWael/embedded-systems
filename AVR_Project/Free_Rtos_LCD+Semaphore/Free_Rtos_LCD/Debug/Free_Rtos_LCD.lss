
Free_Rtos_LCD.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000017f2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000020  00800060  000017f2  00001886  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000486  00800080  00800080  000018a6  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000018a6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000018d8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000003e8  00000000  00000000  00001914  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004628  00000000  00000000  00001cfc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000010ed  00000000  00000000  00006324  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002932  00000000  00000000  00007411  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000c2c  00000000  00000000  00009d44  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000158f  00000000  00000000  0000a970  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00004329  00000000  00000000  0000beff  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000003d0  00000000  00000000  00010228  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 32 03 	jmp	0x664	; 0x664 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e2 ef       	ldi	r30, 0xF2	; 242
      68:	f7 e1       	ldi	r31, 0x17	; 23
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a0 38       	cpi	r26, 0x80	; 128
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	25 e0       	ldi	r18, 0x05	; 5
      78:	a0 e8       	ldi	r26, 0x80	; 128
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a6 30       	cpi	r26, 0x06	; 6
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 b3 0b 	call	0x1766	; 0x1766 <main>
      8a:	0c 94 f7 0b 	jmp	0x17ee	; 0x17ee <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <DIO_void_Set_pin_val>:
		switch(copy_u8_port)
		{
			case PORTA:TOGGLE_BIT(PORTA_REG,copy_u8_pin);break;
			case PORTB:TOGGLE_BIT(PORTB_REG,copy_u8_pin);break;
			case PORTC:TOGGLE_BIT(PORTC_REG,copy_u8_pin);break;
			case PORTD:TOGGLE_BIT(PORTD_REG,copy_u8_pin);break;
      92:	68 30       	cpi	r22, 0x08	; 8
      94:	08 f0       	brcs	.+2      	; 0x98 <DIO_void_Set_pin_val+0x6>
      96:	6d c0       	rjmp	.+218    	; 0x172 <DIO_void_Set_pin_val+0xe0>
      98:	41 30       	cpi	r20, 0x01	; 1
      9a:	a1 f5       	brne	.+104    	; 0x104 <DIO_void_Set_pin_val+0x72>
      9c:	81 30       	cpi	r24, 0x01	; 1
      9e:	89 f0       	breq	.+34     	; 0xc2 <DIO_void_Set_pin_val+0x30>
      a0:	28 f0       	brcs	.+10     	; 0xac <DIO_void_Set_pin_val+0x1a>
      a2:	82 30       	cpi	r24, 0x02	; 2
      a4:	c9 f0       	breq	.+50     	; 0xd8 <DIO_void_Set_pin_val+0x46>
      a6:	83 30       	cpi	r24, 0x03	; 3
      a8:	11 f1       	breq	.+68     	; 0xee <DIO_void_Set_pin_val+0x5c>
      aa:	08 95       	ret
      ac:	2b b3       	in	r18, 0x1b	; 27
      ae:	81 e0       	ldi	r24, 0x01	; 1
      b0:	90 e0       	ldi	r25, 0x00	; 0
      b2:	02 c0       	rjmp	.+4      	; 0xb8 <DIO_void_Set_pin_val+0x26>
      b4:	88 0f       	add	r24, r24
      b6:	99 1f       	adc	r25, r25
      b8:	6a 95       	dec	r22
      ba:	e2 f7       	brpl	.-8      	; 0xb4 <DIO_void_Set_pin_val+0x22>
      bc:	82 2b       	or	r24, r18
      be:	8b bb       	out	0x1b, r24	; 27
      c0:	08 95       	ret
      c2:	28 b3       	in	r18, 0x18	; 24
      c4:	81 e0       	ldi	r24, 0x01	; 1
      c6:	90 e0       	ldi	r25, 0x00	; 0
      c8:	02 c0       	rjmp	.+4      	; 0xce <DIO_void_Set_pin_val+0x3c>
      ca:	88 0f       	add	r24, r24
      cc:	99 1f       	adc	r25, r25
      ce:	6a 95       	dec	r22
      d0:	e2 f7       	brpl	.-8      	; 0xca <DIO_void_Set_pin_val+0x38>
      d2:	82 2b       	or	r24, r18
      d4:	88 bb       	out	0x18, r24	; 24
      d6:	08 95       	ret
      d8:	25 b3       	in	r18, 0x15	; 21
      da:	81 e0       	ldi	r24, 0x01	; 1
      dc:	90 e0       	ldi	r25, 0x00	; 0
      de:	02 c0       	rjmp	.+4      	; 0xe4 <DIO_void_Set_pin_val+0x52>
      e0:	88 0f       	add	r24, r24
      e2:	99 1f       	adc	r25, r25
      e4:	6a 95       	dec	r22
      e6:	e2 f7       	brpl	.-8      	; 0xe0 <DIO_void_Set_pin_val+0x4e>
      e8:	82 2b       	or	r24, r18
      ea:	85 bb       	out	0x15, r24	; 21
      ec:	08 95       	ret
      ee:	22 b3       	in	r18, 0x12	; 18
      f0:	81 e0       	ldi	r24, 0x01	; 1
      f2:	90 e0       	ldi	r25, 0x00	; 0
      f4:	02 c0       	rjmp	.+4      	; 0xfa <DIO_void_Set_pin_val+0x68>
      f6:	88 0f       	add	r24, r24
      f8:	99 1f       	adc	r25, r25
      fa:	6a 95       	dec	r22
      fc:	e2 f7       	brpl	.-8      	; 0xf6 <DIO_void_Set_pin_val+0x64>
      fe:	82 2b       	or	r24, r18
     100:	82 bb       	out	0x12, r24	; 18
     102:	08 95       	ret
     104:	81 30       	cpi	r24, 0x01	; 1
     106:	91 f0       	breq	.+36     	; 0x12c <DIO_void_Set_pin_val+0x9a>
     108:	28 f0       	brcs	.+10     	; 0x114 <DIO_void_Set_pin_val+0x82>
     10a:	82 30       	cpi	r24, 0x02	; 2
     10c:	d9 f0       	breq	.+54     	; 0x144 <DIO_void_Set_pin_val+0xb2>
     10e:	83 30       	cpi	r24, 0x03	; 3
     110:	29 f1       	breq	.+74     	; 0x15c <DIO_void_Set_pin_val+0xca>
     112:	08 95       	ret
     114:	2b b3       	in	r18, 0x1b	; 27
     116:	81 e0       	ldi	r24, 0x01	; 1
     118:	90 e0       	ldi	r25, 0x00	; 0
     11a:	02 c0       	rjmp	.+4      	; 0x120 <DIO_void_Set_pin_val+0x8e>
     11c:	88 0f       	add	r24, r24
     11e:	99 1f       	adc	r25, r25
     120:	6a 95       	dec	r22
     122:	e2 f7       	brpl	.-8      	; 0x11c <DIO_void_Set_pin_val+0x8a>
     124:	80 95       	com	r24
     126:	82 23       	and	r24, r18
     128:	8b bb       	out	0x1b, r24	; 27
     12a:	08 95       	ret
     12c:	28 b3       	in	r18, 0x18	; 24
     12e:	81 e0       	ldi	r24, 0x01	; 1
     130:	90 e0       	ldi	r25, 0x00	; 0
     132:	02 c0       	rjmp	.+4      	; 0x138 <DIO_void_Set_pin_val+0xa6>
     134:	88 0f       	add	r24, r24
     136:	99 1f       	adc	r25, r25
     138:	6a 95       	dec	r22
     13a:	e2 f7       	brpl	.-8      	; 0x134 <DIO_void_Set_pin_val+0xa2>
     13c:	80 95       	com	r24
     13e:	82 23       	and	r24, r18
     140:	88 bb       	out	0x18, r24	; 24
     142:	08 95       	ret
     144:	25 b3       	in	r18, 0x15	; 21
     146:	81 e0       	ldi	r24, 0x01	; 1
     148:	90 e0       	ldi	r25, 0x00	; 0
     14a:	02 c0       	rjmp	.+4      	; 0x150 <DIO_void_Set_pin_val+0xbe>
     14c:	88 0f       	add	r24, r24
     14e:	99 1f       	adc	r25, r25
     150:	6a 95       	dec	r22
     152:	e2 f7       	brpl	.-8      	; 0x14c <DIO_void_Set_pin_val+0xba>
     154:	80 95       	com	r24
     156:	82 23       	and	r24, r18
     158:	85 bb       	out	0x15, r24	; 21
     15a:	08 95       	ret
     15c:	22 b3       	in	r18, 0x12	; 18
     15e:	81 e0       	ldi	r24, 0x01	; 1
     160:	90 e0       	ldi	r25, 0x00	; 0
     162:	02 c0       	rjmp	.+4      	; 0x168 <DIO_void_Set_pin_val+0xd6>
     164:	88 0f       	add	r24, r24
     166:	99 1f       	adc	r25, r25
     168:	6a 95       	dec	r22
     16a:	e2 f7       	brpl	.-8      	; 0x164 <DIO_void_Set_pin_val+0xd2>
     16c:	80 95       	com	r24
     16e:	82 23       	and	r24, r18
     170:	82 bb       	out	0x12, r24	; 18
     172:	08 95       	ret

00000174 <set_port_dir>:
	}
}

void set_port_dir(u8 copy_u8_port,u8 copy_u8_dir)
{
	if (copy_u8_dir == OUTPUT)
     174:	61 30       	cpi	r22, 0x01	; 1
     176:	99 f4       	brne	.+38     	; 0x19e <set_port_dir+0x2a>
	{
		switch(copy_u8_port)
     178:	81 30       	cpi	r24, 0x01	; 1
     17a:	49 f0       	breq	.+18     	; 0x18e <set_port_dir+0x1a>
     17c:	28 f0       	brcs	.+10     	; 0x188 <set_port_dir+0x14>
     17e:	82 30       	cpi	r24, 0x02	; 2
     180:	49 f0       	breq	.+18     	; 0x194 <set_port_dir+0x20>
     182:	83 30       	cpi	r24, 0x03	; 3
     184:	51 f0       	breq	.+20     	; 0x19a <set_port_dir+0x26>
     186:	0b c0       	rjmp	.+22     	; 0x19e <set_port_dir+0x2a>
		{
			case PORTA: DDRA_REG = 0Xff;break;
     188:	9f ef       	ldi	r25, 0xFF	; 255
     18a:	9a bb       	out	0x1a, r25	; 26
     18c:	08 c0       	rjmp	.+16     	; 0x19e <set_port_dir+0x2a>
			case PORTB: DDRB_REG = 0Xff;break;
     18e:	9f ef       	ldi	r25, 0xFF	; 255
     190:	97 bb       	out	0x17, r25	; 23
     192:	05 c0       	rjmp	.+10     	; 0x19e <set_port_dir+0x2a>
			case PORTC: DDRC_REG = 0Xff;break;
     194:	9f ef       	ldi	r25, 0xFF	; 255
     196:	94 bb       	out	0x14, r25	; 20
     198:	02 c0       	rjmp	.+4      	; 0x19e <set_port_dir+0x2a>
			case PORTD: DDRD_REG = 0Xff;break;
     19a:	9f ef       	ldi	r25, 0xFF	; 255
     19c:	91 bb       	out	0x11, r25	; 17
		}
	}
	if (copy_u8_dir == INPUT)
     19e:	61 11       	cpse	r22, r1
     1a0:	0f c0       	rjmp	.+30     	; 0x1c0 <set_port_dir+0x4c>
	{
		switch(copy_u8_port)
     1a2:	81 30       	cpi	r24, 0x01	; 1
     1a4:	41 f0       	breq	.+16     	; 0x1b6 <set_port_dir+0x42>
     1a6:	28 f0       	brcs	.+10     	; 0x1b2 <set_port_dir+0x3e>
     1a8:	82 30       	cpi	r24, 0x02	; 2
     1aa:	39 f0       	breq	.+14     	; 0x1ba <set_port_dir+0x46>
     1ac:	83 30       	cpi	r24, 0x03	; 3
     1ae:	39 f0       	breq	.+14     	; 0x1be <set_port_dir+0x4a>
     1b0:	08 95       	ret
		{
			case PORTA: DDRA_REG = 0X00;break;
     1b2:	1a ba       	out	0x1a, r1	; 26
     1b4:	08 95       	ret
			case PORTB: DDRB_REG = 0X00;break;
     1b6:	17 ba       	out	0x17, r1	; 23
     1b8:	08 95       	ret
			case PORTC: DDRC_REG = 0X00;break;
     1ba:	14 ba       	out	0x14, r1	; 20
     1bc:	08 95       	ret
			case PORTD: DDRD_REG = 0X00;break;
     1be:	11 ba       	out	0x11, r1	; 17
     1c0:	08 95       	ret

000001c2 <prvHeapInit>:
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     1c2:	e5 e8       	ldi	r30, 0x85	; 133
     1c4:	f0 e0       	ldi	r31, 0x00	; 0
     1c6:	8a e8       	ldi	r24, 0x8A	; 138
     1c8:	90 e0       	ldi	r25, 0x00	; 0
     1ca:	91 83       	std	Z+1, r25	; 0x01
     1cc:	80 83       	st	Z, r24
	xStart.xBlockSize = ( size_t ) 0;
     1ce:	13 82       	std	Z+3, r1	; 0x03
     1d0:	12 82       	std	Z+2, r1	; 0x02

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
     1d2:	e1 e8       	ldi	r30, 0x81	; 129
     1d4:	f0 e0       	ldi	r31, 0x00	; 0
     1d6:	87 ee       	ldi	r24, 0xE7	; 231
     1d8:	93 e0       	ldi	r25, 0x03	; 3
     1da:	93 83       	std	Z+3, r25	; 0x03
     1dc:	82 83       	std	Z+2, r24	; 0x02
	xEnd.pxNextFreeBlock = NULL;
     1de:	11 82       	std	Z+1, r1	; 0x01
     1e0:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
     1e2:	a9 e8       	ldi	r26, 0x89	; 137
     1e4:	b0 e0       	ldi	r27, 0x00	; 0
     1e6:	14 96       	adiw	r26, 0x04	; 4
     1e8:	9c 93       	st	X, r25
     1ea:	8e 93       	st	-X, r24
     1ec:	13 97       	sbiw	r26, 0x03	; 3
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
     1ee:	12 96       	adiw	r26, 0x02	; 2
     1f0:	fc 93       	st	X, r31
     1f2:	ee 93       	st	-X, r30
     1f4:	11 97       	sbiw	r26, 0x01	; 1
     1f6:	08 95       	ret

000001f8 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     1f8:	0f 93       	push	r16
     1fa:	1f 93       	push	r17
     1fc:	cf 93       	push	r28
     1fe:	df 93       	push	r29
     200:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
     202:	0e 94 db 07 	call	0xfb6	; 0xfb6 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
     206:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__data_end>
     20a:	81 11       	cpse	r24, r1
     20c:	05 c0       	rjmp	.+10     	; 0x218 <pvPortMalloc+0x20>
		{
			prvHeapInit();
     20e:	0e 94 e1 00 	call	0x1c2	; 0x1c2 <prvHeapInit>
			xHeapHasBeenInitialised = pdTRUE;
     212:	81 e0       	ldi	r24, 0x01	; 1
     214:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__data_end>
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
     218:	20 97       	sbiw	r28, 0x00	; 0
     21a:	09 f0       	breq	.+2      	; 0x21e <pvPortMalloc+0x26>
		{
			xWantedSize += heapSTRUCT_SIZE;
     21c:	24 96       	adiw	r28, 0x04	; 4
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
     21e:	ce 01       	movw	r24, r28
     220:	01 97       	sbiw	r24, 0x01	; 1
     222:	86 3e       	cpi	r24, 0xE6	; 230
     224:	93 40       	sbci	r25, 0x03	; 3
     226:	08 f0       	brcs	.+2      	; 0x22a <pvPortMalloc+0x32>
     228:	56 c0       	rjmp	.+172    	; 0x2d6 <pvPortMalloc+0xde>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
     22a:	e0 91 85 00 	lds	r30, 0x0085	; 0x800085 <xStart>
     22e:	f0 91 86 00 	lds	r31, 0x0086	; 0x800086 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     232:	a5 e8       	ldi	r26, 0x85	; 133
     234:	b0 e0       	ldi	r27, 0x00	; 0
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     236:	02 c0       	rjmp	.+4      	; 0x23c <pvPortMalloc+0x44>
			{
				pxPreviousBlock = pxBlock;
     238:	df 01       	movw	r26, r30
				pxBlock = pxBlock->pxNextFreeBlock;
     23a:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     23c:	82 81       	ldd	r24, Z+2	; 0x02
     23e:	93 81       	ldd	r25, Z+3	; 0x03
     240:	8c 17       	cp	r24, r28
     242:	9d 07       	cpc	r25, r29
     244:	20 f4       	brcc	.+8      	; 0x24e <pvPortMalloc+0x56>
     246:	80 81       	ld	r24, Z
     248:	91 81       	ldd	r25, Z+1	; 0x01
     24a:	00 97       	sbiw	r24, 0x00	; 0
     24c:	a9 f7       	brne	.-22     	; 0x238 <pvPortMalloc+0x40>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     24e:	80 e0       	ldi	r24, 0x00	; 0
     250:	e1 38       	cpi	r30, 0x81	; 129
     252:	f8 07       	cpc	r31, r24
     254:	09 f4       	brne	.+2      	; 0x258 <pvPortMalloc+0x60>
     256:	42 c0       	rjmp	.+132    	; 0x2dc <pvPortMalloc+0xe4>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     258:	0d 91       	ld	r16, X+
     25a:	1c 91       	ld	r17, X
     25c:	11 97       	sbiw	r26, 0x01	; 1
     25e:	0c 5f       	subi	r16, 0xFC	; 252
     260:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     262:	80 81       	ld	r24, Z
     264:	91 81       	ldd	r25, Z+1	; 0x01
     266:	8d 93       	st	X+, r24
     268:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     26a:	82 81       	ldd	r24, Z+2	; 0x02
     26c:	93 81       	ldd	r25, Z+3	; 0x03
     26e:	8c 1b       	sub	r24, r28
     270:	9d 0b       	sbc	r25, r29
     272:	89 30       	cpi	r24, 0x09	; 9
     274:	91 05       	cpc	r25, r1
     276:	10 f1       	brcs	.+68     	; 0x2bc <pvPortMalloc+0xc4>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     278:	af 01       	movw	r20, r30
     27a:	4c 0f       	add	r20, r28
     27c:	5d 1f       	adc	r21, r29

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     27e:	da 01       	movw	r26, r20
     280:	13 96       	adiw	r26, 0x03	; 3
     282:	9c 93       	st	X, r25
     284:	8e 93       	st	-X, r24
     286:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
     288:	d3 83       	std	Z+3, r29	; 0x03
     28a:	c2 83       	std	Z+2, r28	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     28c:	12 96       	adiw	r26, 0x02	; 2
     28e:	2d 91       	ld	r18, X+
     290:	3c 91       	ld	r19, X
     292:	13 97       	sbiw	r26, 0x03	; 3
     294:	65 e8       	ldi	r22, 0x85	; 133
     296:	70 e0       	ldi	r23, 0x00	; 0
     298:	01 c0       	rjmp	.+2      	; 0x29c <pvPortMalloc+0xa4>
     29a:	bd 01       	movw	r22, r26
     29c:	eb 01       	movw	r28, r22
     29e:	a8 81       	ld	r26, Y
     2a0:	b9 81       	ldd	r27, Y+1	; 0x01
     2a2:	12 96       	adiw	r26, 0x02	; 2
     2a4:	8d 91       	ld	r24, X+
     2a6:	9c 91       	ld	r25, X
     2a8:	13 97       	sbiw	r26, 0x03	; 3
     2aa:	82 17       	cp	r24, r18
     2ac:	93 07       	cpc	r25, r19
     2ae:	a8 f3       	brcs	.-22     	; 0x29a <pvPortMalloc+0xa2>
     2b0:	ea 01       	movw	r28, r20
     2b2:	b9 83       	std	Y+1, r27	; 0x01
     2b4:	a8 83       	st	Y, r26
     2b6:	db 01       	movw	r26, r22
     2b8:	4d 93       	st	X+, r20
     2ba:	5c 93       	st	X, r21
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
     2bc:	22 81       	ldd	r18, Z+2	; 0x02
     2be:	33 81       	ldd	r19, Z+3	; 0x03
     2c0:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
     2c4:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     2c8:	82 1b       	sub	r24, r18
     2ca:	93 0b       	sbc	r25, r19
     2cc:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     2d0:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
     2d4:	05 c0       	rjmp	.+10     	; 0x2e0 <pvPortMalloc+0xe8>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     2d6:	00 e0       	ldi	r16, 0x00	; 0
     2d8:	10 e0       	ldi	r17, 0x00	; 0
     2da:	02 c0       	rjmp	.+4      	; 0x2e0 <pvPortMalloc+0xe8>
     2dc:	00 e0       	ldi	r16, 0x00	; 0
     2de:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     2e0:	0e 94 6b 08 	call	0x10d6	; 0x10d6 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     2e4:	c8 01       	movw	r24, r16
     2e6:	df 91       	pop	r29
     2e8:	cf 91       	pop	r28
     2ea:	1f 91       	pop	r17
     2ec:	0f 91       	pop	r16
     2ee:	08 95       	ret

000002f0 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     2f0:	0f 93       	push	r16
     2f2:	1f 93       	push	r17
     2f4:	cf 93       	push	r28
     2f6:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     2f8:	00 97       	sbiw	r24, 0x00	; 0
     2fa:	41 f1       	breq	.+80     	; 0x34c <vPortFree+0x5c>
     2fc:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
     2fe:	8c 01       	movw	r16, r24
     300:	04 50       	subi	r16, 0x04	; 4
     302:	11 09       	sbc	r17, r1

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
     304:	0e 94 db 07 	call	0xfb6	; 0xfb6 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     308:	f8 01       	movw	r30, r16
     30a:	42 81       	ldd	r20, Z+2	; 0x02
     30c:	53 81       	ldd	r21, Z+3	; 0x03
     30e:	a5 e8       	ldi	r26, 0x85	; 133
     310:	b0 e0       	ldi	r27, 0x00	; 0
     312:	01 c0       	rjmp	.+2      	; 0x316 <vPortFree+0x26>
     314:	df 01       	movw	r26, r30
     316:	ed 91       	ld	r30, X+
     318:	fc 91       	ld	r31, X
     31a:	11 97       	sbiw	r26, 0x01	; 1
     31c:	22 81       	ldd	r18, Z+2	; 0x02
     31e:	33 81       	ldd	r19, Z+3	; 0x03
     320:	24 17       	cp	r18, r20
     322:	35 07       	cpc	r19, r21
     324:	b8 f3       	brcs	.-18     	; 0x314 <vPortFree+0x24>
     326:	24 97       	sbiw	r28, 0x04	; 4
     328:	f9 83       	std	Y+1, r31	; 0x01
     32a:	e8 83       	st	Y, r30
     32c:	0d 93       	st	X+, r16
     32e:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     330:	8a 81       	ldd	r24, Y+2	; 0x02
     332:	9b 81       	ldd	r25, Y+3	; 0x03
     334:	20 91 60 00 	lds	r18, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
     338:	30 91 61 00 	lds	r19, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     33c:	82 0f       	add	r24, r18
     33e:	93 1f       	adc	r25, r19
     340:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     344:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
     348:	0e 94 6b 08 	call	0x10d6	; 0x10d6 <xTaskResumeAll>
	}
}
     34c:	df 91       	pop	r29
     34e:	cf 91       	pop	r28
     350:	1f 91       	pop	r17
     352:	0f 91       	pop	r16
     354:	08 95       	ret

00000356 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     356:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     358:	03 96       	adiw	r24, 0x03	; 3
     35a:	92 83       	std	Z+2, r25	; 0x02
     35c:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     35e:	2f ef       	ldi	r18, 0xFF	; 255
     360:	3f ef       	ldi	r19, 0xFF	; 255
     362:	34 83       	std	Z+4, r19	; 0x04
     364:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     366:	96 83       	std	Z+6, r25	; 0x06
     368:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     36a:	90 87       	std	Z+8, r25	; 0x08
     36c:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     36e:	10 82       	st	Z, r1
     370:	08 95       	ret

00000372 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     372:	fc 01       	movw	r30, r24
     374:	11 86       	std	Z+9, r1	; 0x09
     376:	10 86       	std	Z+8, r1	; 0x08
     378:	08 95       	ret

0000037a <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     37a:	cf 93       	push	r28
     37c:	df 93       	push	r29
     37e:	9c 01       	movw	r18, r24
     380:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     382:	dc 01       	movw	r26, r24
     384:	11 96       	adiw	r26, 0x01	; 1
     386:	cd 91       	ld	r28, X+
     388:	dc 91       	ld	r29, X
     38a:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     38c:	d3 83       	std	Z+3, r29	; 0x03
     38e:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     390:	8c 81       	ldd	r24, Y+4	; 0x04
     392:	9d 81       	ldd	r25, Y+5	; 0x05
     394:	95 83       	std	Z+5, r25	; 0x05
     396:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     398:	8c 81       	ldd	r24, Y+4	; 0x04
     39a:	9d 81       	ldd	r25, Y+5	; 0x05
     39c:	dc 01       	movw	r26, r24
     39e:	13 96       	adiw	r26, 0x03	; 3
     3a0:	7c 93       	st	X, r23
     3a2:	6e 93       	st	-X, r22
     3a4:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     3a6:	7d 83       	std	Y+5, r23	; 0x05
     3a8:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     3aa:	31 87       	std	Z+9, r19	; 0x09
     3ac:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     3ae:	f9 01       	movw	r30, r18
     3b0:	80 81       	ld	r24, Z
     3b2:	8f 5f       	subi	r24, 0xFF	; 255
     3b4:	80 83       	st	Z, r24
}
     3b6:	df 91       	pop	r29
     3b8:	cf 91       	pop	r28
     3ba:	08 95       	ret

000003bc <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     3bc:	cf 93       	push	r28
     3be:	df 93       	push	r29
     3c0:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     3c2:	48 81       	ld	r20, Y
     3c4:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     3c6:	4f 3f       	cpi	r20, 0xFF	; 255
     3c8:	2f ef       	ldi	r18, 0xFF	; 255
     3ca:	52 07       	cpc	r21, r18
     3cc:	21 f4       	brne	.+8      	; 0x3d6 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     3ce:	fc 01       	movw	r30, r24
     3d0:	a7 81       	ldd	r26, Z+7	; 0x07
     3d2:	b0 85       	ldd	r27, Z+8	; 0x08
     3d4:	0d c0       	rjmp	.+26     	; 0x3f0 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     3d6:	dc 01       	movw	r26, r24
     3d8:	13 96       	adiw	r26, 0x03	; 3
     3da:	01 c0       	rjmp	.+2      	; 0x3de <vListInsert+0x22>
     3dc:	df 01       	movw	r26, r30
     3de:	12 96       	adiw	r26, 0x02	; 2
     3e0:	ed 91       	ld	r30, X+
     3e2:	fc 91       	ld	r31, X
     3e4:	13 97       	sbiw	r26, 0x03	; 3
     3e6:	20 81       	ld	r18, Z
     3e8:	31 81       	ldd	r19, Z+1	; 0x01
     3ea:	42 17       	cp	r20, r18
     3ec:	53 07       	cpc	r21, r19
     3ee:	b0 f7       	brcc	.-20     	; 0x3dc <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     3f0:	12 96       	adiw	r26, 0x02	; 2
     3f2:	ed 91       	ld	r30, X+
     3f4:	fc 91       	ld	r31, X
     3f6:	13 97       	sbiw	r26, 0x03	; 3
     3f8:	fb 83       	std	Y+3, r31	; 0x03
     3fa:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     3fc:	d5 83       	std	Z+5, r29	; 0x05
     3fe:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     400:	bd 83       	std	Y+5, r27	; 0x05
     402:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     404:	13 96       	adiw	r26, 0x03	; 3
     406:	dc 93       	st	X, r29
     408:	ce 93       	st	-X, r28
     40a:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     40c:	99 87       	std	Y+9, r25	; 0x09
     40e:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     410:	fc 01       	movw	r30, r24
     412:	20 81       	ld	r18, Z
     414:	2f 5f       	subi	r18, 0xFF	; 255
     416:	20 83       	st	Z, r18
}
     418:	df 91       	pop	r29
     41a:	cf 91       	pop	r28
     41c:	08 95       	ret

0000041e <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     41e:	cf 93       	push	r28
     420:	df 93       	push	r29
     422:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     424:	a0 85       	ldd	r26, Z+8	; 0x08
     426:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     428:	c2 81       	ldd	r28, Z+2	; 0x02
     42a:	d3 81       	ldd	r29, Z+3	; 0x03
     42c:	84 81       	ldd	r24, Z+4	; 0x04
     42e:	95 81       	ldd	r25, Z+5	; 0x05
     430:	9d 83       	std	Y+5, r25	; 0x05
     432:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     434:	c4 81       	ldd	r28, Z+4	; 0x04
     436:	d5 81       	ldd	r29, Z+5	; 0x05
     438:	82 81       	ldd	r24, Z+2	; 0x02
     43a:	93 81       	ldd	r25, Z+3	; 0x03
     43c:	9b 83       	std	Y+3, r25	; 0x03
     43e:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     440:	11 96       	adiw	r26, 0x01	; 1
     442:	8d 91       	ld	r24, X+
     444:	9c 91       	ld	r25, X
     446:	12 97       	sbiw	r26, 0x02	; 2
     448:	e8 17       	cp	r30, r24
     44a:	f9 07       	cpc	r31, r25
     44c:	31 f4       	brne	.+12     	; 0x45a <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     44e:	84 81       	ldd	r24, Z+4	; 0x04
     450:	95 81       	ldd	r25, Z+5	; 0x05
     452:	12 96       	adiw	r26, 0x02	; 2
     454:	9c 93       	st	X, r25
     456:	8e 93       	st	-X, r24
     458:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     45a:	11 86       	std	Z+9, r1	; 0x09
     45c:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     45e:	8c 91       	ld	r24, X
     460:	81 50       	subi	r24, 0x01	; 1
     462:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     464:	df 91       	pop	r29
     466:	cf 91       	pop	r28
     468:	08 95       	ret

0000046a <prvSetupTimerInterrupt>:
	{
		vTaskSwitchContext();
	}
	portRESTORE_CONTEXT();

	asm volatile ( "ret" );
     46a:	1b bc       	out	0x2b, r1	; 43
     46c:	89 ef       	ldi	r24, 0xF9	; 249
     46e:	8a bd       	out	0x2a, r24	; 42
     470:	8b e0       	ldi	r24, 0x0B	; 11
     472:	8e bd       	out	0x2e, r24	; 46
     474:	89 b7       	in	r24, 0x39	; 57
     476:	80 61       	ori	r24, 0x10	; 16
     478:	89 bf       	out	0x39, r24	; 57
     47a:	08 95       	ret

0000047c <pxPortInitialiseStack>:
     47c:	31 e1       	ldi	r19, 0x11	; 17
     47e:	fc 01       	movw	r30, r24
     480:	30 83       	st	Z, r19
     482:	31 97       	sbiw	r30, 0x01	; 1
     484:	22 e2       	ldi	r18, 0x22	; 34
     486:	20 83       	st	Z, r18
     488:	31 97       	sbiw	r30, 0x01	; 1
     48a:	a3 e3       	ldi	r26, 0x33	; 51
     48c:	a0 83       	st	Z, r26
     48e:	31 97       	sbiw	r30, 0x01	; 1
     490:	60 83       	st	Z, r22
     492:	31 97       	sbiw	r30, 0x01	; 1
     494:	70 83       	st	Z, r23
     496:	31 97       	sbiw	r30, 0x01	; 1
     498:	10 82       	st	Z, r1
     49a:	31 97       	sbiw	r30, 0x01	; 1
     49c:	60 e8       	ldi	r22, 0x80	; 128
     49e:	60 83       	st	Z, r22
     4a0:	31 97       	sbiw	r30, 0x01	; 1
     4a2:	10 82       	st	Z, r1
     4a4:	31 97       	sbiw	r30, 0x01	; 1
     4a6:	62 e0       	ldi	r22, 0x02	; 2
     4a8:	60 83       	st	Z, r22
     4aa:	31 97       	sbiw	r30, 0x01	; 1
     4ac:	63 e0       	ldi	r22, 0x03	; 3
     4ae:	60 83       	st	Z, r22
     4b0:	31 97       	sbiw	r30, 0x01	; 1
     4b2:	64 e0       	ldi	r22, 0x04	; 4
     4b4:	60 83       	st	Z, r22
     4b6:	31 97       	sbiw	r30, 0x01	; 1
     4b8:	65 e0       	ldi	r22, 0x05	; 5
     4ba:	60 83       	st	Z, r22
     4bc:	31 97       	sbiw	r30, 0x01	; 1
     4be:	66 e0       	ldi	r22, 0x06	; 6
     4c0:	60 83       	st	Z, r22
     4c2:	31 97       	sbiw	r30, 0x01	; 1
     4c4:	67 e0       	ldi	r22, 0x07	; 7
     4c6:	60 83       	st	Z, r22
     4c8:	31 97       	sbiw	r30, 0x01	; 1
     4ca:	68 e0       	ldi	r22, 0x08	; 8
     4cc:	60 83       	st	Z, r22
     4ce:	31 97       	sbiw	r30, 0x01	; 1
     4d0:	69 e0       	ldi	r22, 0x09	; 9
     4d2:	60 83       	st	Z, r22
     4d4:	31 97       	sbiw	r30, 0x01	; 1
     4d6:	60 e1       	ldi	r22, 0x10	; 16
     4d8:	60 83       	st	Z, r22
     4da:	31 97       	sbiw	r30, 0x01	; 1
     4dc:	30 83       	st	Z, r19
     4de:	31 97       	sbiw	r30, 0x01	; 1
     4e0:	32 e1       	ldi	r19, 0x12	; 18
     4e2:	30 83       	st	Z, r19
     4e4:	31 97       	sbiw	r30, 0x01	; 1
     4e6:	33 e1       	ldi	r19, 0x13	; 19
     4e8:	30 83       	st	Z, r19
     4ea:	31 97       	sbiw	r30, 0x01	; 1
     4ec:	34 e1       	ldi	r19, 0x14	; 20
     4ee:	30 83       	st	Z, r19
     4f0:	31 97       	sbiw	r30, 0x01	; 1
     4f2:	35 e1       	ldi	r19, 0x15	; 21
     4f4:	30 83       	st	Z, r19
     4f6:	31 97       	sbiw	r30, 0x01	; 1
     4f8:	36 e1       	ldi	r19, 0x16	; 22
     4fa:	30 83       	st	Z, r19
     4fc:	31 97       	sbiw	r30, 0x01	; 1
     4fe:	37 e1       	ldi	r19, 0x17	; 23
     500:	30 83       	st	Z, r19
     502:	31 97       	sbiw	r30, 0x01	; 1
     504:	38 e1       	ldi	r19, 0x18	; 24
     506:	30 83       	st	Z, r19
     508:	31 97       	sbiw	r30, 0x01	; 1
     50a:	39 e1       	ldi	r19, 0x19	; 25
     50c:	30 83       	st	Z, r19
     50e:	31 97       	sbiw	r30, 0x01	; 1
     510:	30 e2       	ldi	r19, 0x20	; 32
     512:	30 83       	st	Z, r19
     514:	31 97       	sbiw	r30, 0x01	; 1
     516:	31 e2       	ldi	r19, 0x21	; 33
     518:	30 83       	st	Z, r19
     51a:	31 97       	sbiw	r30, 0x01	; 1
     51c:	20 83       	st	Z, r18
     51e:	31 97       	sbiw	r30, 0x01	; 1
     520:	23 e2       	ldi	r18, 0x23	; 35
     522:	20 83       	st	Z, r18
     524:	31 97       	sbiw	r30, 0x01	; 1
     526:	40 83       	st	Z, r20
     528:	31 97       	sbiw	r30, 0x01	; 1
     52a:	50 83       	st	Z, r21
     52c:	31 97       	sbiw	r30, 0x01	; 1
     52e:	26 e2       	ldi	r18, 0x26	; 38
     530:	20 83       	st	Z, r18
     532:	31 97       	sbiw	r30, 0x01	; 1
     534:	27 e2       	ldi	r18, 0x27	; 39
     536:	20 83       	st	Z, r18
     538:	31 97       	sbiw	r30, 0x01	; 1
     53a:	28 e2       	ldi	r18, 0x28	; 40
     53c:	20 83       	st	Z, r18
     53e:	31 97       	sbiw	r30, 0x01	; 1
     540:	29 e2       	ldi	r18, 0x29	; 41
     542:	20 83       	st	Z, r18
     544:	31 97       	sbiw	r30, 0x01	; 1
     546:	20 e3       	ldi	r18, 0x30	; 48
     548:	20 83       	st	Z, r18
     54a:	31 97       	sbiw	r30, 0x01	; 1
     54c:	21 e3       	ldi	r18, 0x31	; 49
     54e:	20 83       	st	Z, r18
     550:	86 97       	sbiw	r24, 0x26	; 38
     552:	08 95       	ret

00000554 <xPortStartScheduler>:
     554:	0e 94 35 02 	call	0x46a	; 0x46a <prvSetupTimerInterrupt>
     558:	a0 91 02 05 	lds	r26, 0x0502	; 0x800502 <pxCurrentTCB>
     55c:	b0 91 03 05 	lds	r27, 0x0503	; 0x800503 <pxCurrentTCB+0x1>
     560:	cd 91       	ld	r28, X+
     562:	cd bf       	out	0x3d, r28	; 61
     564:	dd 91       	ld	r29, X+
     566:	de bf       	out	0x3e, r29	; 62
     568:	ff 91       	pop	r31
     56a:	ef 91       	pop	r30
     56c:	df 91       	pop	r29
     56e:	cf 91       	pop	r28
     570:	bf 91       	pop	r27
     572:	af 91       	pop	r26
     574:	9f 91       	pop	r25
     576:	8f 91       	pop	r24
     578:	7f 91       	pop	r23
     57a:	6f 91       	pop	r22
     57c:	5f 91       	pop	r21
     57e:	4f 91       	pop	r20
     580:	3f 91       	pop	r19
     582:	2f 91       	pop	r18
     584:	1f 91       	pop	r17
     586:	0f 91       	pop	r16
     588:	ff 90       	pop	r15
     58a:	ef 90       	pop	r14
     58c:	df 90       	pop	r13
     58e:	cf 90       	pop	r12
     590:	bf 90       	pop	r11
     592:	af 90       	pop	r10
     594:	9f 90       	pop	r9
     596:	8f 90       	pop	r8
     598:	7f 90       	pop	r7
     59a:	6f 90       	pop	r6
     59c:	5f 90       	pop	r5
     59e:	4f 90       	pop	r4
     5a0:	3f 90       	pop	r3
     5a2:	2f 90       	pop	r2
     5a4:	1f 90       	pop	r1
     5a6:	0f 90       	pop	r0
     5a8:	0f be       	out	0x3f, r0	; 63
     5aa:	0f 90       	pop	r0
     5ac:	08 95       	ret
     5ae:	81 e0       	ldi	r24, 0x01	; 1
     5b0:	08 95       	ret

000005b2 <vPortYield>:
     5b2:	0f 92       	push	r0
     5b4:	0f b6       	in	r0, 0x3f	; 63
     5b6:	f8 94       	cli
     5b8:	0f 92       	push	r0
     5ba:	1f 92       	push	r1
     5bc:	11 24       	eor	r1, r1
     5be:	2f 92       	push	r2
     5c0:	3f 92       	push	r3
     5c2:	4f 92       	push	r4
     5c4:	5f 92       	push	r5
     5c6:	6f 92       	push	r6
     5c8:	7f 92       	push	r7
     5ca:	8f 92       	push	r8
     5cc:	9f 92       	push	r9
     5ce:	af 92       	push	r10
     5d0:	bf 92       	push	r11
     5d2:	cf 92       	push	r12
     5d4:	df 92       	push	r13
     5d6:	ef 92       	push	r14
     5d8:	ff 92       	push	r15
     5da:	0f 93       	push	r16
     5dc:	1f 93       	push	r17
     5de:	2f 93       	push	r18
     5e0:	3f 93       	push	r19
     5e2:	4f 93       	push	r20
     5e4:	5f 93       	push	r21
     5e6:	6f 93       	push	r22
     5e8:	7f 93       	push	r23
     5ea:	8f 93       	push	r24
     5ec:	9f 93       	push	r25
     5ee:	af 93       	push	r26
     5f0:	bf 93       	push	r27
     5f2:	cf 93       	push	r28
     5f4:	df 93       	push	r29
     5f6:	ef 93       	push	r30
     5f8:	ff 93       	push	r31
     5fa:	a0 91 02 05 	lds	r26, 0x0502	; 0x800502 <pxCurrentTCB>
     5fe:	b0 91 03 05 	lds	r27, 0x0503	; 0x800503 <pxCurrentTCB+0x1>
     602:	0d b6       	in	r0, 0x3d	; 61
     604:	0d 92       	st	X+, r0
     606:	0e b6       	in	r0, 0x3e	; 62
     608:	0d 92       	st	X+, r0
     60a:	0e 94 1e 09 	call	0x123c	; 0x123c <vTaskSwitchContext>
     60e:	a0 91 02 05 	lds	r26, 0x0502	; 0x800502 <pxCurrentTCB>
     612:	b0 91 03 05 	lds	r27, 0x0503	; 0x800503 <pxCurrentTCB+0x1>
     616:	cd 91       	ld	r28, X+
     618:	cd bf       	out	0x3d, r28	; 61
     61a:	dd 91       	ld	r29, X+
     61c:	de bf       	out	0x3e, r29	; 62
     61e:	ff 91       	pop	r31
     620:	ef 91       	pop	r30
     622:	df 91       	pop	r29
     624:	cf 91       	pop	r28
     626:	bf 91       	pop	r27
     628:	af 91       	pop	r26
     62a:	9f 91       	pop	r25
     62c:	8f 91       	pop	r24
     62e:	7f 91       	pop	r23
     630:	6f 91       	pop	r22
     632:	5f 91       	pop	r21
     634:	4f 91       	pop	r20
     636:	3f 91       	pop	r19
     638:	2f 91       	pop	r18
     63a:	1f 91       	pop	r17
     63c:	0f 91       	pop	r16
     63e:	ff 90       	pop	r15
     640:	ef 90       	pop	r14
     642:	df 90       	pop	r13
     644:	cf 90       	pop	r12
     646:	bf 90       	pop	r11
     648:	af 90       	pop	r10
     64a:	9f 90       	pop	r9
     64c:	8f 90       	pop	r8
     64e:	7f 90       	pop	r7
     650:	6f 90       	pop	r6
     652:	5f 90       	pop	r5
     654:	4f 90       	pop	r4
     656:	3f 90       	pop	r3
     658:	2f 90       	pop	r2
     65a:	1f 90       	pop	r1
     65c:	0f 90       	pop	r0
     65e:	0f be       	out	0x3f, r0	; 63
     660:	0f 90       	pop	r0
     662:	08 95       	ret

00000664 <__vector_7>:
	 * tick count.  We don't need to switch context, this can only be done by
	 * manual calls to taskYIELD();
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal ) );
	void TIMER1_COMPA_vect( void )
	{
     664:	1f 92       	push	r1
     666:	0f 92       	push	r0
     668:	0f b6       	in	r0, 0x3f	; 63
     66a:	0f 92       	push	r0
     66c:	11 24       	eor	r1, r1
     66e:	2f 93       	push	r18
     670:	3f 93       	push	r19
     672:	4f 93       	push	r20
     674:	5f 93       	push	r21
     676:	6f 93       	push	r22
     678:	7f 93       	push	r23
     67a:	8f 93       	push	r24
     67c:	9f 93       	push	r25
     67e:	af 93       	push	r26
     680:	bf 93       	push	r27
     682:	ef 93       	push	r30
     684:	ff 93       	push	r31
		xTaskIncrementTick();
     686:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <xTaskIncrementTick>
	}
     68a:	ff 91       	pop	r31
     68c:	ef 91       	pop	r30
     68e:	bf 91       	pop	r27
     690:	af 91       	pop	r26
     692:	9f 91       	pop	r25
     694:	8f 91       	pop	r24
     696:	7f 91       	pop	r23
     698:	6f 91       	pop	r22
     69a:	5f 91       	pop	r21
     69c:	4f 91       	pop	r20
     69e:	3f 91       	pop	r19
     6a0:	2f 91       	pop	r18
     6a2:	0f 90       	pop	r0
     6a4:	0f be       	out	0x3f, r0	; 63
     6a6:	0f 90       	pop	r0
     6a8:	1f 90       	pop	r1
     6aa:	18 95       	reti

000006ac <prvIsQueueEmpty>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     6ac:	0f b6       	in	r0, 0x3f	; 63
     6ae:	f8 94       	cli
     6b0:	0f 92       	push	r0
     6b2:	fc 01       	movw	r30, r24
     6b4:	82 8d       	ldd	r24, Z+26	; 0x1a
     6b6:	81 11       	cpse	r24, r1
     6b8:	02 c0       	rjmp	.+4      	; 0x6be <prvIsQueueEmpty+0x12>
     6ba:	81 e0       	ldi	r24, 0x01	; 1
     6bc:	01 c0       	rjmp	.+2      	; 0x6c0 <prvIsQueueEmpty+0x14>
     6be:	80 e0       	ldi	r24, 0x00	; 0
     6c0:	0f 90       	pop	r0
     6c2:	0f be       	out	0x3f, r0	; 63
     6c4:	08 95       	ret

000006c6 <prvIsQueueFull>:
     6c6:	0f b6       	in	r0, 0x3f	; 63
     6c8:	f8 94       	cli
     6ca:	0f 92       	push	r0
     6cc:	fc 01       	movw	r30, r24
     6ce:	22 8d       	ldd	r18, Z+26	; 0x1a
     6d0:	83 8d       	ldd	r24, Z+27	; 0x1b
     6d2:	28 13       	cpse	r18, r24
     6d4:	02 c0       	rjmp	.+4      	; 0x6da <prvIsQueueFull+0x14>
     6d6:	81 e0       	ldi	r24, 0x01	; 1
     6d8:	01 c0       	rjmp	.+2      	; 0x6dc <prvIsQueueFull+0x16>
     6da:	80 e0       	ldi	r24, 0x00	; 0
     6dc:	0f 90       	pop	r0
     6de:	0f be       	out	0x3f, r0	; 63
     6e0:	08 95       	ret

000006e2 <prvCopyDataToQueue>:
     6e2:	0f 93       	push	r16
     6e4:	1f 93       	push	r17
     6e6:	cf 93       	push	r28
     6e8:	df 93       	push	r29
     6ea:	ec 01       	movw	r28, r24
     6ec:	04 2f       	mov	r16, r20
     6ee:	1a 8d       	ldd	r17, Y+26	; 0x1a
     6f0:	4c 8d       	ldd	r20, Y+28	; 0x1c
     6f2:	41 11       	cpse	r20, r1
     6f4:	0c c0       	rjmp	.+24     	; 0x70e <prvCopyDataToQueue+0x2c>
     6f6:	88 81       	ld	r24, Y
     6f8:	99 81       	ldd	r25, Y+1	; 0x01
     6fa:	89 2b       	or	r24, r25
     6fc:	09 f0       	breq	.+2      	; 0x700 <prvCopyDataToQueue+0x1e>
     6fe:	42 c0       	rjmp	.+132    	; 0x784 <prvCopyDataToQueue+0xa2>
     700:	8a 81       	ldd	r24, Y+2	; 0x02
     702:	9b 81       	ldd	r25, Y+3	; 0x03
     704:	0e 94 76 0a 	call	0x14ec	; 0x14ec <xTaskPriorityDisinherit>
     708:	1b 82       	std	Y+3, r1	; 0x03
     70a:	1a 82       	std	Y+2, r1	; 0x02
     70c:	42 c0       	rjmp	.+132    	; 0x792 <prvCopyDataToQueue+0xb0>
     70e:	01 11       	cpse	r16, r1
     710:	17 c0       	rjmp	.+46     	; 0x740 <prvCopyDataToQueue+0x5e>
     712:	50 e0       	ldi	r21, 0x00	; 0
     714:	8c 81       	ldd	r24, Y+4	; 0x04
     716:	9d 81       	ldd	r25, Y+5	; 0x05
     718:	0e 94 ee 0b 	call	0x17dc	; 0x17dc <memcpy>
     71c:	2c 8d       	ldd	r18, Y+28	; 0x1c
     71e:	8c 81       	ldd	r24, Y+4	; 0x04
     720:	9d 81       	ldd	r25, Y+5	; 0x05
     722:	82 0f       	add	r24, r18
     724:	91 1d       	adc	r25, r1
     726:	9d 83       	std	Y+5, r25	; 0x05
     728:	8c 83       	std	Y+4, r24	; 0x04
     72a:	2a 81       	ldd	r18, Y+2	; 0x02
     72c:	3b 81       	ldd	r19, Y+3	; 0x03
     72e:	82 17       	cp	r24, r18
     730:	93 07       	cpc	r25, r19
     732:	50 f1       	brcs	.+84     	; 0x788 <prvCopyDataToQueue+0xa6>
     734:	88 81       	ld	r24, Y
     736:	99 81       	ldd	r25, Y+1	; 0x01
     738:	9d 83       	std	Y+5, r25	; 0x05
     73a:	8c 83       	std	Y+4, r24	; 0x04
     73c:	80 e0       	ldi	r24, 0x00	; 0
     73e:	29 c0       	rjmp	.+82     	; 0x792 <prvCopyDataToQueue+0xb0>
     740:	50 e0       	ldi	r21, 0x00	; 0
     742:	8e 81       	ldd	r24, Y+6	; 0x06
     744:	9f 81       	ldd	r25, Y+7	; 0x07
     746:	0e 94 ee 0b 	call	0x17dc	; 0x17dc <memcpy>
     74a:	8c 8d       	ldd	r24, Y+28	; 0x1c
     74c:	90 e0       	ldi	r25, 0x00	; 0
     74e:	91 95       	neg	r25
     750:	81 95       	neg	r24
     752:	91 09       	sbc	r25, r1
     754:	2e 81       	ldd	r18, Y+6	; 0x06
     756:	3f 81       	ldd	r19, Y+7	; 0x07
     758:	28 0f       	add	r18, r24
     75a:	39 1f       	adc	r19, r25
     75c:	3f 83       	std	Y+7, r19	; 0x07
     75e:	2e 83       	std	Y+6, r18	; 0x06
     760:	48 81       	ld	r20, Y
     762:	59 81       	ldd	r21, Y+1	; 0x01
     764:	24 17       	cp	r18, r20
     766:	35 07       	cpc	r19, r21
     768:	30 f4       	brcc	.+12     	; 0x776 <prvCopyDataToQueue+0x94>
     76a:	2a 81       	ldd	r18, Y+2	; 0x02
     76c:	3b 81       	ldd	r19, Y+3	; 0x03
     76e:	82 0f       	add	r24, r18
     770:	93 1f       	adc	r25, r19
     772:	9f 83       	std	Y+7, r25	; 0x07
     774:	8e 83       	std	Y+6, r24	; 0x06
     776:	02 30       	cpi	r16, 0x02	; 2
     778:	49 f4       	brne	.+18     	; 0x78c <prvCopyDataToQueue+0xaa>
     77a:	11 23       	and	r17, r17
     77c:	49 f0       	breq	.+18     	; 0x790 <prvCopyDataToQueue+0xae>
     77e:	11 50       	subi	r17, 0x01	; 1
     780:	80 e0       	ldi	r24, 0x00	; 0
     782:	07 c0       	rjmp	.+14     	; 0x792 <prvCopyDataToQueue+0xb0>
     784:	80 e0       	ldi	r24, 0x00	; 0
     786:	05 c0       	rjmp	.+10     	; 0x792 <prvCopyDataToQueue+0xb0>
     788:	80 e0       	ldi	r24, 0x00	; 0
     78a:	03 c0       	rjmp	.+6      	; 0x792 <prvCopyDataToQueue+0xb0>
     78c:	80 e0       	ldi	r24, 0x00	; 0
     78e:	01 c0       	rjmp	.+2      	; 0x792 <prvCopyDataToQueue+0xb0>
     790:	80 e0       	ldi	r24, 0x00	; 0
     792:	1f 5f       	subi	r17, 0xFF	; 255
     794:	1a 8f       	std	Y+26, r17	; 0x1a
     796:	df 91       	pop	r29
     798:	cf 91       	pop	r28
     79a:	1f 91       	pop	r17
     79c:	0f 91       	pop	r16
     79e:	08 95       	ret

000007a0 <prvCopyDataFromQueue>:
     7a0:	fc 01       	movw	r30, r24
     7a2:	44 8d       	ldd	r20, Z+28	; 0x1c
     7a4:	44 23       	and	r20, r20
     7a6:	a9 f0       	breq	.+42     	; 0x7d2 <prvCopyDataFromQueue+0x32>
     7a8:	50 e0       	ldi	r21, 0x00	; 0
     7aa:	26 81       	ldd	r18, Z+6	; 0x06
     7ac:	37 81       	ldd	r19, Z+7	; 0x07
     7ae:	24 0f       	add	r18, r20
     7b0:	35 1f       	adc	r19, r21
     7b2:	37 83       	std	Z+7, r19	; 0x07
     7b4:	26 83       	std	Z+6, r18	; 0x06
     7b6:	82 81       	ldd	r24, Z+2	; 0x02
     7b8:	93 81       	ldd	r25, Z+3	; 0x03
     7ba:	28 17       	cp	r18, r24
     7bc:	39 07       	cpc	r19, r25
     7be:	20 f0       	brcs	.+8      	; 0x7c8 <prvCopyDataFromQueue+0x28>
     7c0:	80 81       	ld	r24, Z
     7c2:	91 81       	ldd	r25, Z+1	; 0x01
     7c4:	97 83       	std	Z+7, r25	; 0x07
     7c6:	86 83       	std	Z+6, r24	; 0x06
     7c8:	cb 01       	movw	r24, r22
     7ca:	66 81       	ldd	r22, Z+6	; 0x06
     7cc:	77 81       	ldd	r23, Z+7	; 0x07
     7ce:	0e 94 ee 0b 	call	0x17dc	; 0x17dc <memcpy>
     7d2:	08 95       	ret

000007d4 <prvUnlockQueue>:
     7d4:	1f 93       	push	r17
     7d6:	cf 93       	push	r28
     7d8:	df 93       	push	r29
     7da:	ec 01       	movw	r28, r24
     7dc:	0f b6       	in	r0, 0x3f	; 63
     7de:	f8 94       	cli
     7e0:	0f 92       	push	r0
     7e2:	1e 8d       	ldd	r17, Y+30	; 0x1e
     7e4:	0b c0       	rjmp	.+22     	; 0x7fc <prvUnlockQueue+0x28>
     7e6:	89 89       	ldd	r24, Y+17	; 0x11
     7e8:	88 23       	and	r24, r24
     7ea:	51 f0       	breq	.+20     	; 0x800 <__DATA_REGION_LENGTH__>
     7ec:	ce 01       	movw	r24, r28
     7ee:	41 96       	adiw	r24, 0x11	; 17
     7f0:	0e 94 84 09 	call	0x1308	; 0x1308 <xTaskRemoveFromEventList>
     7f4:	81 11       	cpse	r24, r1
     7f6:	0e 94 10 0a 	call	0x1420	; 0x1420 <vTaskMissedYield>
     7fa:	11 50       	subi	r17, 0x01	; 1
     7fc:	11 16       	cp	r1, r17
     7fe:	9c f3       	brlt	.-26     	; 0x7e6 <prvUnlockQueue+0x12>
     800:	8f ef       	ldi	r24, 0xFF	; 255
     802:	8e 8f       	std	Y+30, r24	; 0x1e
     804:	0f 90       	pop	r0
     806:	0f be       	out	0x3f, r0	; 63
     808:	0f b6       	in	r0, 0x3f	; 63
     80a:	f8 94       	cli
     80c:	0f 92       	push	r0
     80e:	1d 8d       	ldd	r17, Y+29	; 0x1d
     810:	0b c0       	rjmp	.+22     	; 0x828 <__DATA_REGION_LENGTH__+0x28>
     812:	88 85       	ldd	r24, Y+8	; 0x08
     814:	88 23       	and	r24, r24
     816:	51 f0       	breq	.+20     	; 0x82c <__DATA_REGION_LENGTH__+0x2c>
     818:	ce 01       	movw	r24, r28
     81a:	08 96       	adiw	r24, 0x08	; 8
     81c:	0e 94 84 09 	call	0x1308	; 0x1308 <xTaskRemoveFromEventList>
     820:	81 11       	cpse	r24, r1
     822:	0e 94 10 0a 	call	0x1420	; 0x1420 <vTaskMissedYield>
     826:	11 50       	subi	r17, 0x01	; 1
     828:	11 16       	cp	r1, r17
     82a:	9c f3       	brlt	.-26     	; 0x812 <__DATA_REGION_LENGTH__+0x12>
     82c:	8f ef       	ldi	r24, 0xFF	; 255
     82e:	8d 8f       	std	Y+29, r24	; 0x1d
     830:	0f 90       	pop	r0
     832:	0f be       	out	0x3f, r0	; 63
     834:	df 91       	pop	r29
     836:	cf 91       	pop	r28
     838:	1f 91       	pop	r17
     83a:	08 95       	ret

0000083c <xQueueGenericReset>:
     83c:	cf 93       	push	r28
     83e:	df 93       	push	r29
     840:	ec 01       	movw	r28, r24
     842:	0f b6       	in	r0, 0x3f	; 63
     844:	f8 94       	cli
     846:	0f 92       	push	r0
     848:	e8 81       	ld	r30, Y
     84a:	f9 81       	ldd	r31, Y+1	; 0x01
     84c:	8b 8d       	ldd	r24, Y+27	; 0x1b
     84e:	90 e0       	ldi	r25, 0x00	; 0
     850:	2c 8d       	ldd	r18, Y+28	; 0x1c
     852:	30 e0       	ldi	r19, 0x00	; 0
     854:	82 9f       	mul	r24, r18
     856:	a0 01       	movw	r20, r0
     858:	83 9f       	mul	r24, r19
     85a:	50 0d       	add	r21, r0
     85c:	92 9f       	mul	r25, r18
     85e:	50 0d       	add	r21, r0
     860:	11 24       	eor	r1, r1
     862:	4e 0f       	add	r20, r30
     864:	5f 1f       	adc	r21, r31
     866:	5b 83       	std	Y+3, r21	; 0x03
     868:	4a 83       	std	Y+2, r20	; 0x02
     86a:	1a 8e       	std	Y+26, r1	; 0x1a
     86c:	fd 83       	std	Y+5, r31	; 0x05
     86e:	ec 83       	std	Y+4, r30	; 0x04
     870:	01 97       	sbiw	r24, 0x01	; 1
     872:	28 9f       	mul	r18, r24
     874:	a0 01       	movw	r20, r0
     876:	29 9f       	mul	r18, r25
     878:	50 0d       	add	r21, r0
     87a:	38 9f       	mul	r19, r24
     87c:	50 0d       	add	r21, r0
     87e:	11 24       	eor	r1, r1
     880:	cf 01       	movw	r24, r30
     882:	84 0f       	add	r24, r20
     884:	95 1f       	adc	r25, r21
     886:	9f 83       	std	Y+7, r25	; 0x07
     888:	8e 83       	std	Y+6, r24	; 0x06
     88a:	8f ef       	ldi	r24, 0xFF	; 255
     88c:	8d 8f       	std	Y+29, r24	; 0x1d
     88e:	8e 8f       	std	Y+30, r24	; 0x1e
     890:	61 11       	cpse	r22, r1
     892:	08 c0       	rjmp	.+16     	; 0x8a4 <__stack+0x45>
     894:	88 85       	ldd	r24, Y+8	; 0x08
     896:	88 23       	and	r24, r24
     898:	69 f0       	breq	.+26     	; 0x8b4 <__stack+0x55>
     89a:	ce 01       	movw	r24, r28
     89c:	08 96       	adiw	r24, 0x08	; 8
     89e:	0e 94 84 09 	call	0x1308	; 0x1308 <xTaskRemoveFromEventList>
     8a2:	08 c0       	rjmp	.+16     	; 0x8b4 <__stack+0x55>
     8a4:	ce 01       	movw	r24, r28
     8a6:	08 96       	adiw	r24, 0x08	; 8
     8a8:	0e 94 ab 01 	call	0x356	; 0x356 <vListInitialise>
     8ac:	ce 01       	movw	r24, r28
     8ae:	41 96       	adiw	r24, 0x11	; 17
     8b0:	0e 94 ab 01 	call	0x356	; 0x356 <vListInitialise>
     8b4:	0f 90       	pop	r0
     8b6:	0f be       	out	0x3f, r0	; 63
     8b8:	81 e0       	ldi	r24, 0x01	; 1
     8ba:	df 91       	pop	r29
     8bc:	cf 91       	pop	r28
     8be:	08 95       	ret

000008c0 <prvInitialiseNewQueue>:
     8c0:	0f 93       	push	r16
     8c2:	1f 93       	push	r17
     8c4:	f8 01       	movw	r30, r16
     8c6:	61 11       	cpse	r22, r1
     8c8:	03 c0       	rjmp	.+6      	; 0x8d0 <prvInitialiseNewQueue+0x10>
     8ca:	11 83       	std	Z+1, r17	; 0x01
     8cc:	00 83       	st	Z, r16
     8ce:	02 c0       	rjmp	.+4      	; 0x8d4 <prvInitialiseNewQueue+0x14>
     8d0:	51 83       	std	Z+1, r21	; 0x01
     8d2:	40 83       	st	Z, r20
     8d4:	83 8f       	std	Z+27, r24	; 0x1b
     8d6:	64 8f       	std	Z+28, r22	; 0x1c
     8d8:	61 e0       	ldi	r22, 0x01	; 1
     8da:	cf 01       	movw	r24, r30
     8dc:	0e 94 1e 04 	call	0x83c	; 0x83c <xQueueGenericReset>
     8e0:	1f 91       	pop	r17
     8e2:	0f 91       	pop	r16
     8e4:	08 95       	ret

000008e6 <xQueueGenericCreate>:
     8e6:	df 92       	push	r13
     8e8:	ef 92       	push	r14
     8ea:	ff 92       	push	r15
     8ec:	0f 93       	push	r16
     8ee:	1f 93       	push	r17
     8f0:	cf 93       	push	r28
     8f2:	df 93       	push	r29
     8f4:	e8 2e       	mov	r14, r24
     8f6:	f6 2e       	mov	r15, r22
     8f8:	d4 2e       	mov	r13, r20
     8fa:	66 23       	and	r22, r22
     8fc:	21 f0       	breq	.+8      	; 0x906 <xQueueGenericCreate+0x20>
     8fe:	86 9f       	mul	r24, r22
     900:	c0 01       	movw	r24, r0
     902:	11 24       	eor	r1, r1
     904:	02 c0       	rjmp	.+4      	; 0x90a <xQueueGenericCreate+0x24>
     906:	80 e0       	ldi	r24, 0x00	; 0
     908:	90 e0       	ldi	r25, 0x00	; 0
     90a:	4f 96       	adiw	r24, 0x1f	; 31
     90c:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <pvPortMalloc>
     910:	ec 01       	movw	r28, r24
     912:	00 97       	sbiw	r24, 0x00	; 0
     914:	49 f0       	breq	.+18     	; 0x928 <xQueueGenericCreate+0x42>
     916:	8c 01       	movw	r16, r24
     918:	2d 2d       	mov	r18, r13
     91a:	ac 01       	movw	r20, r24
     91c:	41 5e       	subi	r20, 0xE1	; 225
     91e:	5f 4f       	sbci	r21, 0xFF	; 255
     920:	6f 2d       	mov	r22, r15
     922:	8e 2d       	mov	r24, r14
     924:	0e 94 60 04 	call	0x8c0	; 0x8c0 <prvInitialiseNewQueue>
     928:	ce 01       	movw	r24, r28
     92a:	df 91       	pop	r29
     92c:	cf 91       	pop	r28
     92e:	1f 91       	pop	r17
     930:	0f 91       	pop	r16
     932:	ff 90       	pop	r15
     934:	ef 90       	pop	r14
     936:	df 90       	pop	r13
     938:	08 95       	ret

0000093a <xQueueGenericSend>:
     93a:	cf 92       	push	r12
     93c:	df 92       	push	r13
     93e:	ef 92       	push	r14
     940:	ff 92       	push	r15
     942:	0f 93       	push	r16
     944:	1f 93       	push	r17
     946:	cf 93       	push	r28
     948:	df 93       	push	r29
     94a:	00 d0       	rcall	.+0      	; 0x94c <xQueueGenericSend+0x12>
     94c:	00 d0       	rcall	.+0      	; 0x94e <xQueueGenericSend+0x14>
     94e:	1f 92       	push	r1
     950:	cd b7       	in	r28, 0x3d	; 61
     952:	de b7       	in	r29, 0x3e	; 62
     954:	8c 01       	movw	r16, r24
     956:	7b 01       	movw	r14, r22
     958:	5d 83       	std	Y+5, r21	; 0x05
     95a:	4c 83       	std	Y+4, r20	; 0x04
     95c:	c2 2e       	mov	r12, r18
     95e:	d1 2c       	mov	r13, r1
     960:	0f b6       	in	r0, 0x3f	; 63
     962:	f8 94       	cli
     964:	0f 92       	push	r0
     966:	f8 01       	movw	r30, r16
     968:	92 8d       	ldd	r25, Z+26	; 0x1a
     96a:	83 8d       	ldd	r24, Z+27	; 0x1b
     96c:	98 17       	cp	r25, r24
     96e:	18 f0       	brcs	.+6      	; 0x976 <xQueueGenericSend+0x3c>
     970:	f2 e0       	ldi	r31, 0x02	; 2
     972:	cf 12       	cpse	r12, r31
     974:	11 c0       	rjmp	.+34     	; 0x998 <xQueueGenericSend+0x5e>
     976:	4c 2d       	mov	r20, r12
     978:	b7 01       	movw	r22, r14
     97a:	c8 01       	movw	r24, r16
     97c:	0e 94 71 03 	call	0x6e2	; 0x6e2 <prvCopyDataToQueue>
     980:	f8 01       	movw	r30, r16
     982:	81 89       	ldd	r24, Z+17	; 0x11
     984:	88 23       	and	r24, r24
     986:	21 f0       	breq	.+8      	; 0x990 <xQueueGenericSend+0x56>
     988:	c8 01       	movw	r24, r16
     98a:	41 96       	adiw	r24, 0x11	; 17
     98c:	0e 94 84 09 	call	0x1308	; 0x1308 <xTaskRemoveFromEventList>
     990:	0f 90       	pop	r0
     992:	0f be       	out	0x3f, r0	; 63
     994:	81 e0       	ldi	r24, 0x01	; 1
     996:	4d c0       	rjmp	.+154    	; 0xa32 <xQueueGenericSend+0xf8>
     998:	8c 81       	ldd	r24, Y+4	; 0x04
     99a:	9d 81       	ldd	r25, Y+5	; 0x05
     99c:	89 2b       	or	r24, r25
     99e:	21 f4       	brne	.+8      	; 0x9a8 <xQueueGenericSend+0x6e>
     9a0:	0f 90       	pop	r0
     9a2:	0f be       	out	0x3f, r0	; 63
     9a4:	80 e0       	ldi	r24, 0x00	; 0
     9a6:	45 c0       	rjmp	.+138    	; 0xa32 <xQueueGenericSend+0xf8>
     9a8:	d1 10       	cpse	r13, r1
     9aa:	06 c0       	rjmp	.+12     	; 0x9b8 <xQueueGenericSend+0x7e>
     9ac:	ce 01       	movw	r24, r28
     9ae:	01 96       	adiw	r24, 0x01	; 1
     9b0:	0e 94 cc 09 	call	0x1398	; 0x1398 <vTaskSetTimeOutState>
     9b4:	dd 24       	eor	r13, r13
     9b6:	d3 94       	inc	r13
     9b8:	0f 90       	pop	r0
     9ba:	0f be       	out	0x3f, r0	; 63
     9bc:	0e 94 db 07 	call	0xfb6	; 0xfb6 <vTaskSuspendAll>
     9c0:	0f b6       	in	r0, 0x3f	; 63
     9c2:	f8 94       	cli
     9c4:	0f 92       	push	r0
     9c6:	f8 01       	movw	r30, r16
     9c8:	85 8d       	ldd	r24, Z+29	; 0x1d
     9ca:	8f 3f       	cpi	r24, 0xFF	; 255
     9cc:	09 f4       	brne	.+2      	; 0x9d0 <xQueueGenericSend+0x96>
     9ce:	15 8e       	std	Z+29, r1	; 0x1d
     9d0:	f8 01       	movw	r30, r16
     9d2:	86 8d       	ldd	r24, Z+30	; 0x1e
     9d4:	8f 3f       	cpi	r24, 0xFF	; 255
     9d6:	09 f4       	brne	.+2      	; 0x9da <xQueueGenericSend+0xa0>
     9d8:	16 8e       	std	Z+30, r1	; 0x1e
     9da:	0f 90       	pop	r0
     9dc:	0f be       	out	0x3f, r0	; 63
     9de:	be 01       	movw	r22, r28
     9e0:	6c 5f       	subi	r22, 0xFC	; 252
     9e2:	7f 4f       	sbci	r23, 0xFF	; 255
     9e4:	ce 01       	movw	r24, r28
     9e6:	01 96       	adiw	r24, 0x01	; 1
     9e8:	0e 94 d7 09 	call	0x13ae	; 0x13ae <xTaskCheckForTimeOut>
     9ec:	81 11       	cpse	r24, r1
     9ee:	1b c0       	rjmp	.+54     	; 0xa26 <xQueueGenericSend+0xec>
     9f0:	c8 01       	movw	r24, r16
     9f2:	0e 94 63 03 	call	0x6c6	; 0x6c6 <prvIsQueueFull>
     9f6:	88 23       	and	r24, r24
     9f8:	81 f0       	breq	.+32     	; 0xa1a <xQueueGenericSend+0xe0>
     9fa:	6c 81       	ldd	r22, Y+4	; 0x04
     9fc:	7d 81       	ldd	r23, Y+5	; 0x05
     9fe:	c8 01       	movw	r24, r16
     a00:	08 96       	adiw	r24, 0x08	; 8
     a02:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vTaskPlaceOnEventList>
     a06:	c8 01       	movw	r24, r16
     a08:	0e 94 ea 03 	call	0x7d4	; 0x7d4 <prvUnlockQueue>
     a0c:	0e 94 6b 08 	call	0x10d6	; 0x10d6 <xTaskResumeAll>
     a10:	81 11       	cpse	r24, r1
     a12:	a6 cf       	rjmp	.-180    	; 0x960 <xQueueGenericSend+0x26>
     a14:	0e 94 d9 02 	call	0x5b2	; 0x5b2 <vPortYield>
     a18:	a3 cf       	rjmp	.-186    	; 0x960 <xQueueGenericSend+0x26>
     a1a:	c8 01       	movw	r24, r16
     a1c:	0e 94 ea 03 	call	0x7d4	; 0x7d4 <prvUnlockQueue>
     a20:	0e 94 6b 08 	call	0x10d6	; 0x10d6 <xTaskResumeAll>
     a24:	9d cf       	rjmp	.-198    	; 0x960 <xQueueGenericSend+0x26>
     a26:	c8 01       	movw	r24, r16
     a28:	0e 94 ea 03 	call	0x7d4	; 0x7d4 <prvUnlockQueue>
     a2c:	0e 94 6b 08 	call	0x10d6	; 0x10d6 <xTaskResumeAll>
     a30:	80 e0       	ldi	r24, 0x00	; 0
     a32:	0f 90       	pop	r0
     a34:	0f 90       	pop	r0
     a36:	0f 90       	pop	r0
     a38:	0f 90       	pop	r0
     a3a:	0f 90       	pop	r0
     a3c:	df 91       	pop	r29
     a3e:	cf 91       	pop	r28
     a40:	1f 91       	pop	r17
     a42:	0f 91       	pop	r16
     a44:	ff 90       	pop	r15
     a46:	ef 90       	pop	r14
     a48:	df 90       	pop	r13
     a4a:	cf 90       	pop	r12
     a4c:	08 95       	ret

00000a4e <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
     a4e:	8f 92       	push	r8
     a50:	9f 92       	push	r9
     a52:	bf 92       	push	r11
     a54:	cf 92       	push	r12
     a56:	df 92       	push	r13
     a58:	ef 92       	push	r14
     a5a:	ff 92       	push	r15
     a5c:	0f 93       	push	r16
     a5e:	1f 93       	push	r17
     a60:	cf 93       	push	r28
     a62:	df 93       	push	r29
     a64:	00 d0       	rcall	.+0      	; 0xa66 <xQueueGenericReceive+0x18>
     a66:	00 d0       	rcall	.+0      	; 0xa68 <xQueueGenericReceive+0x1a>
     a68:	1f 92       	push	r1
     a6a:	cd b7       	in	r28, 0x3d	; 61
     a6c:	de b7       	in	r29, 0x3e	; 62
     a6e:	8c 01       	movw	r16, r24
     a70:	6b 01       	movw	r12, r22
     a72:	5d 83       	std	Y+5, r21	; 0x05
     a74:	4c 83       	std	Y+4, r20	; 0x04
     a76:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
     a78:	e1 2c       	mov	r14, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     a7a:	0f b6       	in	r0, 0x3f	; 63
     a7c:	f8 94       	cli
     a7e:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     a80:	f8 01       	movw	r30, r16
     a82:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     a84:	ff 20       	and	r15, r15
     a86:	59 f1       	breq	.+86     	; 0xade <xQueueGenericReceive+0x90>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     a88:	86 80       	ldd	r8, Z+6	; 0x06
     a8a:	97 80       	ldd	r9, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     a8c:	b6 01       	movw	r22, r12
     a8e:	c8 01       	movw	r24, r16
     a90:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     a94:	b1 10       	cpse	r11, r1
     a96:	15 c0       	rjmp	.+42     	; 0xac2 <xQueueGenericReceive+0x74>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
     a98:	fa 94       	dec	r15
     a9a:	f8 01       	movw	r30, r16
     a9c:	f2 8e       	std	Z+26, r15	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     a9e:	80 81       	ld	r24, Z
     aa0:	91 81       	ldd	r25, Z+1	; 0x01
     aa2:	89 2b       	or	r24, r25
     aa4:	29 f4       	brne	.+10     	; 0xab0 <xQueueGenericReceive+0x62>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
     aa6:	0e 94 b6 0a 	call	0x156c	; 0x156c <pvTaskIncrementMutexHeldCount>
     aaa:	f8 01       	movw	r30, r16
     aac:	93 83       	std	Z+3, r25	; 0x03
     aae:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     ab0:	f8 01       	movw	r30, r16
     ab2:	80 85       	ldd	r24, Z+8	; 0x08
     ab4:	88 23       	and	r24, r24
     ab6:	79 f0       	breq	.+30     	; 0xad6 <xQueueGenericReceive+0x88>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     ab8:	c8 01       	movw	r24, r16
     aba:	08 96       	adiw	r24, 0x08	; 8
     abc:	0e 94 84 09 	call	0x1308	; 0x1308 <xTaskRemoveFromEventList>
     ac0:	0a c0       	rjmp	.+20     	; 0xad6 <xQueueGenericReceive+0x88>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     ac2:	f8 01       	movw	r30, r16
     ac4:	97 82       	std	Z+7, r9	; 0x07
     ac6:	86 82       	std	Z+6, r8	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     ac8:	81 89       	ldd	r24, Z+17	; 0x11
     aca:	88 23       	and	r24, r24
     acc:	21 f0       	breq	.+8      	; 0xad6 <xQueueGenericReceive+0x88>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     ace:	c8 01       	movw	r24, r16
     ad0:	41 96       	adiw	r24, 0x11	; 17
     ad2:	0e 94 84 09 	call	0x1308	; 0x1308 <xTaskRemoveFromEventList>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
     ad6:	0f 90       	pop	r0
     ad8:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     ada:	81 e0       	ldi	r24, 0x01	; 1
     adc:	61 c0       	rjmp	.+194    	; 0xba0 <xQueueGenericReceive+0x152>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     ade:	8c 81       	ldd	r24, Y+4	; 0x04
     ae0:	9d 81       	ldd	r25, Y+5	; 0x05
     ae2:	89 2b       	or	r24, r25
     ae4:	21 f4       	brne	.+8      	; 0xaee <xQueueGenericReceive+0xa0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     ae6:	0f 90       	pop	r0
     ae8:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     aea:	80 e0       	ldi	r24, 0x00	; 0
     aec:	59 c0       	rjmp	.+178    	; 0xba0 <xQueueGenericReceive+0x152>
				}
				else if( xEntryTimeSet == pdFALSE )
     aee:	e1 10       	cpse	r14, r1
     af0:	06 c0       	rjmp	.+12     	; 0xafe <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     af2:	ce 01       	movw	r24, r28
     af4:	01 96       	adiw	r24, 0x01	; 1
     af6:	0e 94 cc 09 	call	0x1398	; 0x1398 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     afa:	ee 24       	eor	r14, r14
     afc:	e3 94       	inc	r14
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     afe:	0f 90       	pop	r0
     b00:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     b02:	0e 94 db 07 	call	0xfb6	; 0xfb6 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     b06:	0f b6       	in	r0, 0x3f	; 63
     b08:	f8 94       	cli
     b0a:	0f 92       	push	r0
     b0c:	f8 01       	movw	r30, r16
     b0e:	85 8d       	ldd	r24, Z+29	; 0x1d
     b10:	8f 3f       	cpi	r24, 0xFF	; 255
     b12:	09 f4       	brne	.+2      	; 0xb16 <xQueueGenericReceive+0xc8>
     b14:	15 8e       	std	Z+29, r1	; 0x1d
     b16:	f8 01       	movw	r30, r16
     b18:	86 8d       	ldd	r24, Z+30	; 0x1e
     b1a:	8f 3f       	cpi	r24, 0xFF	; 255
     b1c:	09 f4       	brne	.+2      	; 0xb20 <xQueueGenericReceive+0xd2>
     b1e:	16 8e       	std	Z+30, r1	; 0x1e
     b20:	0f 90       	pop	r0
     b22:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     b24:	be 01       	movw	r22, r28
     b26:	6c 5f       	subi	r22, 0xFC	; 252
     b28:	7f 4f       	sbci	r23, 0xFF	; 255
     b2a:	ce 01       	movw	r24, r28
     b2c:	01 96       	adiw	r24, 0x01	; 1
     b2e:	0e 94 d7 09 	call	0x13ae	; 0x13ae <xTaskCheckForTimeOut>
     b32:	81 11       	cpse	r24, r1
     b34:	29 c0       	rjmp	.+82     	; 0xb88 <xQueueGenericReceive+0x13a>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     b36:	c8 01       	movw	r24, r16
     b38:	0e 94 56 03 	call	0x6ac	; 0x6ac <prvIsQueueEmpty>
     b3c:	88 23       	and	r24, r24
     b3e:	f1 f0       	breq	.+60     	; 0xb7c <xQueueGenericReceive+0x12e>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     b40:	f8 01       	movw	r30, r16
     b42:	80 81       	ld	r24, Z
     b44:	91 81       	ldd	r25, Z+1	; 0x01
     b46:	89 2b       	or	r24, r25
     b48:	49 f4       	brne	.+18     	; 0xb5c <xQueueGenericReceive+0x10e>
					{
						taskENTER_CRITICAL();
     b4a:	0f b6       	in	r0, 0x3f	; 63
     b4c:	f8 94       	cli
     b4e:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
     b50:	82 81       	ldd	r24, Z+2	; 0x02
     b52:	93 81       	ldd	r25, Z+3	; 0x03
     b54:	0e 94 14 0a 	call	0x1428	; 0x1428 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
     b58:	0f 90       	pop	r0
     b5a:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     b5c:	6c 81       	ldd	r22, Y+4	; 0x04
     b5e:	7d 81       	ldd	r23, Y+5	; 0x05
     b60:	c8 01       	movw	r24, r16
     b62:	41 96       	adiw	r24, 0x11	; 17
     b64:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     b68:	c8 01       	movw	r24, r16
     b6a:	0e 94 ea 03 	call	0x7d4	; 0x7d4 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     b6e:	0e 94 6b 08 	call	0x10d6	; 0x10d6 <xTaskResumeAll>
     b72:	81 11       	cpse	r24, r1
     b74:	82 cf       	rjmp	.-252    	; 0xa7a <xQueueGenericReceive+0x2c>
				{
					portYIELD_WITHIN_API();
     b76:	0e 94 d9 02 	call	0x5b2	; 0x5b2 <vPortYield>
     b7a:	7f cf       	rjmp	.-258    	; 0xa7a <xQueueGenericReceive+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     b7c:	c8 01       	movw	r24, r16
     b7e:	0e 94 ea 03 	call	0x7d4	; 0x7d4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     b82:	0e 94 6b 08 	call	0x10d6	; 0x10d6 <xTaskResumeAll>
     b86:	79 cf       	rjmp	.-270    	; 0xa7a <xQueueGenericReceive+0x2c>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     b88:	c8 01       	movw	r24, r16
     b8a:	0e 94 ea 03 	call	0x7d4	; 0x7d4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     b8e:	0e 94 6b 08 	call	0x10d6	; 0x10d6 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     b92:	c8 01       	movw	r24, r16
     b94:	0e 94 56 03 	call	0x6ac	; 0x6ac <prvIsQueueEmpty>
     b98:	88 23       	and	r24, r24
     b9a:	09 f4       	brne	.+2      	; 0xb9e <xQueueGenericReceive+0x150>
     b9c:	6e cf       	rjmp	.-292    	; 0xa7a <xQueueGenericReceive+0x2c>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
     b9e:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
     ba0:	0f 90       	pop	r0
     ba2:	0f 90       	pop	r0
     ba4:	0f 90       	pop	r0
     ba6:	0f 90       	pop	r0
     ba8:	0f 90       	pop	r0
     baa:	df 91       	pop	r29
     bac:	cf 91       	pop	r28
     bae:	1f 91       	pop	r17
     bb0:	0f 91       	pop	r16
     bb2:	ff 90       	pop	r15
     bb4:	ef 90       	pop	r14
     bb6:	df 90       	pop	r13
     bb8:	cf 90       	pop	r12
     bba:	bf 90       	pop	r11
     bbc:	9f 90       	pop	r9
     bbe:	8f 90       	pop	r8
     bc0:	08 95       	ret

00000bc2 <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
     bc2:	e0 91 9d 04 	lds	r30, 0x049D	; 0x80049d <pxDelayedTaskList>
     bc6:	f0 91 9e 04 	lds	r31, 0x049E	; 0x80049e <pxDelayedTaskList+0x1>
     bca:	80 81       	ld	r24, Z
     bcc:	81 11       	cpse	r24, r1
     bce:	07 c0       	rjmp	.+14     	; 0xbde <prvResetNextTaskUnblockTime+0x1c>
     bd0:	8f ef       	ldi	r24, 0xFF	; 255
     bd2:	9f ef       	ldi	r25, 0xFF	; 255
     bd4:	90 93 75 04 	sts	0x0475, r25	; 0x800475 <xNextTaskUnblockTime+0x1>
     bd8:	80 93 74 04 	sts	0x0474, r24	; 0x800474 <xNextTaskUnblockTime>
     bdc:	08 95       	ret
     bde:	e0 91 9d 04 	lds	r30, 0x049D	; 0x80049d <pxDelayedTaskList>
     be2:	f0 91 9e 04 	lds	r31, 0x049E	; 0x80049e <pxDelayedTaskList+0x1>
     be6:	05 80       	ldd	r0, Z+5	; 0x05
     be8:	f6 81       	ldd	r31, Z+6	; 0x06
     bea:	e0 2d       	mov	r30, r0
     bec:	06 80       	ldd	r0, Z+6	; 0x06
     bee:	f7 81       	ldd	r31, Z+7	; 0x07
     bf0:	e0 2d       	mov	r30, r0
     bf2:	82 81       	ldd	r24, Z+2	; 0x02
     bf4:	93 81       	ldd	r25, Z+3	; 0x03
     bf6:	90 93 75 04 	sts	0x0475, r25	; 0x800475 <xNextTaskUnblockTime+0x1>
     bfa:	80 93 74 04 	sts	0x0474, r24	; 0x800474 <xNextTaskUnblockTime>
     bfe:	08 95       	ret

00000c00 <prvDeleteTCB>:
     c00:	cf 93       	push	r28
     c02:	df 93       	push	r29
     c04:	ec 01       	movw	r28, r24
     c06:	8f 89       	ldd	r24, Y+23	; 0x17
     c08:	98 8d       	ldd	r25, Y+24	; 0x18
     c0a:	0e 94 78 01 	call	0x2f0	; 0x2f0 <vPortFree>
     c0e:	ce 01       	movw	r24, r28
     c10:	0e 94 78 01 	call	0x2f0	; 0x2f0 <vPortFree>
     c14:	df 91       	pop	r29
     c16:	cf 91       	pop	r28
     c18:	08 95       	ret

00000c1a <prvInitialiseNewTask>:
     c1a:	6f 92       	push	r6
     c1c:	7f 92       	push	r7
     c1e:	8f 92       	push	r8
     c20:	9f 92       	push	r9
     c22:	af 92       	push	r10
     c24:	bf 92       	push	r11
     c26:	cf 92       	push	r12
     c28:	df 92       	push	r13
     c2a:	ef 92       	push	r14
     c2c:	0f 93       	push	r16
     c2e:	1f 93       	push	r17
     c30:	cf 93       	push	r28
     c32:	df 93       	push	r29
     c34:	cd b7       	in	r28, 0x3d	; 61
     c36:	de b7       	in	r29, 0x3e	; 62
     c38:	4c 01       	movw	r8, r24
     c3a:	f5 01       	movw	r30, r10
     c3c:	87 89       	ldd	r24, Z+23	; 0x17
     c3e:	90 8d       	ldd	r25, Z+24	; 0x18
     c40:	21 50       	subi	r18, 0x01	; 1
     c42:	31 09       	sbc	r19, r1
     c44:	3c 01       	movw	r6, r24
     c46:	62 0e       	add	r6, r18
     c48:	73 1e       	adc	r7, r19
     c4a:	20 e0       	ldi	r18, 0x00	; 0
     c4c:	0f c0       	rjmp	.+30     	; 0xc6c <prvInitialiseNewTask+0x52>
     c4e:	82 2f       	mov	r24, r18
     c50:	90 e0       	ldi	r25, 0x00	; 0
     c52:	fb 01       	movw	r30, r22
     c54:	e8 0f       	add	r30, r24
     c56:	f9 1f       	adc	r31, r25
     c58:	30 81       	ld	r19, Z
     c5a:	d5 01       	movw	r26, r10
     c5c:	a8 0f       	add	r26, r24
     c5e:	b9 1f       	adc	r27, r25
     c60:	59 96       	adiw	r26, 0x19	; 25
     c62:	3c 93       	st	X, r19
     c64:	80 81       	ld	r24, Z
     c66:	88 23       	and	r24, r24
     c68:	19 f0       	breq	.+6      	; 0xc70 <prvInitialiseNewTask+0x56>
     c6a:	2f 5f       	subi	r18, 0xFF	; 255
     c6c:	28 30       	cpi	r18, 0x08	; 8
     c6e:	78 f3       	brcs	.-34     	; 0xc4e <prvInitialiseNewTask+0x34>
     c70:	f5 01       	movw	r30, r10
     c72:	10 a2       	std	Z+32, r1	; 0x20
     c74:	f8 e0       	ldi	r31, 0x08	; 8
     c76:	fe 15       	cp	r31, r14
     c78:	18 f4       	brcc	.+6      	; 0xc80 <prvInitialiseNewTask+0x66>
     c7a:	68 94       	set
     c7c:	ee 24       	eor	r14, r14
     c7e:	e3 f8       	bld	r14, 3
     c80:	f5 01       	movw	r30, r10
     c82:	e6 8a       	std	Z+22, r14	; 0x16
     c84:	e1 a2       	std	Z+33, r14	; 0x21
     c86:	12 a2       	std	Z+34, r1	; 0x22
     c88:	c5 01       	movw	r24, r10
     c8a:	02 96       	adiw	r24, 0x02	; 2
     c8c:	0e 94 b9 01 	call	0x372	; 0x372 <vListInitialiseItem>
     c90:	c5 01       	movw	r24, r10
     c92:	0c 96       	adiw	r24, 0x0c	; 12
     c94:	0e 94 b9 01 	call	0x372	; 0x372 <vListInitialiseItem>
     c98:	f5 01       	movw	r30, r10
     c9a:	b1 86       	std	Z+9, r11	; 0x09
     c9c:	a0 86       	std	Z+8, r10	; 0x08
     c9e:	89 e0       	ldi	r24, 0x09	; 9
     ca0:	90 e0       	ldi	r25, 0x00	; 0
     ca2:	8e 19       	sub	r24, r14
     ca4:	91 09       	sbc	r25, r1
     ca6:	95 87       	std	Z+13, r25	; 0x0d
     ca8:	84 87       	std	Z+12, r24	; 0x0c
     caa:	b3 8a       	std	Z+19, r11	; 0x13
     cac:	a2 8a       	std	Z+18, r10	; 0x12
     cae:	13 a2       	std	Z+35, r1	; 0x23
     cb0:	14 a2       	std	Z+36, r1	; 0x24
     cb2:	15 a2       	std	Z+37, r1	; 0x25
     cb4:	16 a2       	std	Z+38, r1	; 0x26
     cb6:	17 a2       	std	Z+39, r1	; 0x27
     cb8:	a8 01       	movw	r20, r16
     cba:	b4 01       	movw	r22, r8
     cbc:	c3 01       	movw	r24, r6
     cbe:	0e 94 3e 02 	call	0x47c	; 0x47c <pxPortInitialiseStack>
     cc2:	f5 01       	movw	r30, r10
     cc4:	91 83       	std	Z+1, r25	; 0x01
     cc6:	80 83       	st	Z, r24
     cc8:	c1 14       	cp	r12, r1
     cca:	d1 04       	cpc	r13, r1
     ccc:	19 f0       	breq	.+6      	; 0xcd4 <prvInitialiseNewTask+0xba>
     cce:	f6 01       	movw	r30, r12
     cd0:	b1 82       	std	Z+1, r11	; 0x01
     cd2:	a0 82       	st	Z, r10
     cd4:	df 91       	pop	r29
     cd6:	cf 91       	pop	r28
     cd8:	1f 91       	pop	r17
     cda:	0f 91       	pop	r16
     cdc:	ef 90       	pop	r14
     cde:	df 90       	pop	r13
     ce0:	cf 90       	pop	r12
     ce2:	bf 90       	pop	r11
     ce4:	af 90       	pop	r10
     ce6:	9f 90       	pop	r9
     ce8:	8f 90       	pop	r8
     cea:	7f 90       	pop	r7
     cec:	6f 90       	pop	r6
     cee:	08 95       	ret

00000cf0 <prvInitialiseTaskLists>:
     cf0:	cf 93       	push	r28
     cf2:	c0 e0       	ldi	r28, 0x00	; 0
     cf4:	10 c0       	rjmp	.+32     	; 0xd16 <prvInitialiseTaskLists+0x26>
     cf6:	8c 2f       	mov	r24, r28
     cf8:	90 e0       	ldi	r25, 0x00	; 0
     cfa:	9c 01       	movw	r18, r24
     cfc:	22 0f       	add	r18, r18
     cfe:	33 1f       	adc	r19, r19
     d00:	22 0f       	add	r18, r18
     d02:	33 1f       	adc	r19, r19
     d04:	22 0f       	add	r18, r18
     d06:	33 1f       	adc	r19, r19
     d08:	82 0f       	add	r24, r18
     d0a:	93 1f       	adc	r25, r19
     d0c:	8f 54       	subi	r24, 0x4F	; 79
     d0e:	9b 4f       	sbci	r25, 0xFB	; 251
     d10:	0e 94 ab 01 	call	0x356	; 0x356 <vListInitialise>
     d14:	cf 5f       	subi	r28, 0xFF	; 255
     d16:	c9 30       	cpi	r28, 0x09	; 9
     d18:	70 f3       	brcs	.-36     	; 0xcf6 <prvInitialiseTaskLists+0x6>
     d1a:	88 ea       	ldi	r24, 0xA8	; 168
     d1c:	94 e0       	ldi	r25, 0x04	; 4
     d1e:	0e 94 ab 01 	call	0x356	; 0x356 <vListInitialise>
     d22:	8f e9       	ldi	r24, 0x9F	; 159
     d24:	94 e0       	ldi	r25, 0x04	; 4
     d26:	0e 94 ab 01 	call	0x356	; 0x356 <vListInitialise>
     d2a:	82 e9       	ldi	r24, 0x92	; 146
     d2c:	94 e0       	ldi	r25, 0x04	; 4
     d2e:	0e 94 ab 01 	call	0x356	; 0x356 <vListInitialise>
     d32:	89 e8       	ldi	r24, 0x89	; 137
     d34:	94 e0       	ldi	r25, 0x04	; 4
     d36:	0e 94 ab 01 	call	0x356	; 0x356 <vListInitialise>
     d3a:	8f e7       	ldi	r24, 0x7F	; 127
     d3c:	94 e0       	ldi	r25, 0x04	; 4
     d3e:	0e 94 ab 01 	call	0x356	; 0x356 <vListInitialise>
     d42:	88 ea       	ldi	r24, 0xA8	; 168
     d44:	94 e0       	ldi	r25, 0x04	; 4
     d46:	90 93 9e 04 	sts	0x049E, r25	; 0x80049e <pxDelayedTaskList+0x1>
     d4a:	80 93 9d 04 	sts	0x049D, r24	; 0x80049d <pxDelayedTaskList>
     d4e:	8f e9       	ldi	r24, 0x9F	; 159
     d50:	94 e0       	ldi	r25, 0x04	; 4
     d52:	90 93 9c 04 	sts	0x049C, r25	; 0x80049c <pxOverflowDelayedTaskList+0x1>
     d56:	80 93 9b 04 	sts	0x049B, r24	; 0x80049b <pxOverflowDelayedTaskList>
     d5a:	cf 91       	pop	r28
     d5c:	08 95       	ret

00000d5e <prvAddNewTaskToReadyList>:
     d5e:	cf 93       	push	r28
     d60:	df 93       	push	r29
     d62:	ec 01       	movw	r28, r24
     d64:	0f b6       	in	r0, 0x3f	; 63
     d66:	f8 94       	cli
     d68:	0f 92       	push	r0
     d6a:	80 91 7e 04 	lds	r24, 0x047E	; 0x80047e <uxCurrentNumberOfTasks>
     d6e:	8f 5f       	subi	r24, 0xFF	; 255
     d70:	80 93 7e 04 	sts	0x047E, r24	; 0x80047e <uxCurrentNumberOfTasks>
     d74:	80 91 02 05 	lds	r24, 0x0502	; 0x800502 <pxCurrentTCB>
     d78:	90 91 03 05 	lds	r25, 0x0503	; 0x800503 <pxCurrentTCB+0x1>
     d7c:	89 2b       	or	r24, r25
     d7e:	59 f4       	brne	.+22     	; 0xd96 <prvAddNewTaskToReadyList+0x38>
     d80:	d0 93 03 05 	sts	0x0503, r29	; 0x800503 <pxCurrentTCB+0x1>
     d84:	c0 93 02 05 	sts	0x0502, r28	; 0x800502 <pxCurrentTCB>
     d88:	80 91 7e 04 	lds	r24, 0x047E	; 0x80047e <uxCurrentNumberOfTasks>
     d8c:	81 30       	cpi	r24, 0x01	; 1
     d8e:	99 f4       	brne	.+38     	; 0xdb6 <prvAddNewTaskToReadyList+0x58>
     d90:	0e 94 78 06 	call	0xcf0	; 0xcf0 <prvInitialiseTaskLists>
     d94:	10 c0       	rjmp	.+32     	; 0xdb6 <prvAddNewTaskToReadyList+0x58>
     d96:	80 91 7a 04 	lds	r24, 0x047A	; 0x80047a <xSchedulerRunning>
     d9a:	81 11       	cpse	r24, r1
     d9c:	0c c0       	rjmp	.+24     	; 0xdb6 <prvAddNewTaskToReadyList+0x58>
     d9e:	e0 91 02 05 	lds	r30, 0x0502	; 0x800502 <pxCurrentTCB>
     da2:	f0 91 03 05 	lds	r31, 0x0503	; 0x800503 <pxCurrentTCB+0x1>
     da6:	96 89       	ldd	r25, Z+22	; 0x16
     da8:	8e 89       	ldd	r24, Y+22	; 0x16
     daa:	89 17       	cp	r24, r25
     dac:	20 f0       	brcs	.+8      	; 0xdb6 <prvAddNewTaskToReadyList+0x58>
     dae:	d0 93 03 05 	sts	0x0503, r29	; 0x800503 <pxCurrentTCB+0x1>
     db2:	c0 93 02 05 	sts	0x0502, r28	; 0x800502 <pxCurrentTCB>
     db6:	80 91 76 04 	lds	r24, 0x0476	; 0x800476 <uxTaskNumber>
     dba:	8f 5f       	subi	r24, 0xFF	; 255
     dbc:	80 93 76 04 	sts	0x0476, r24	; 0x800476 <uxTaskNumber>
     dc0:	2e 89       	ldd	r18, Y+22	; 0x16
     dc2:	80 91 7b 04 	lds	r24, 0x047B	; 0x80047b <uxTopReadyPriority>
     dc6:	82 17       	cp	r24, r18
     dc8:	10 f4       	brcc	.+4      	; 0xdce <prvAddNewTaskToReadyList+0x70>
     dca:	20 93 7b 04 	sts	0x047B, r18	; 0x80047b <uxTopReadyPriority>
     dce:	30 e0       	ldi	r19, 0x00	; 0
     dd0:	be 01       	movw	r22, r28
     dd2:	6e 5f       	subi	r22, 0xFE	; 254
     dd4:	7f 4f       	sbci	r23, 0xFF	; 255
     dd6:	c9 01       	movw	r24, r18
     dd8:	88 0f       	add	r24, r24
     dda:	99 1f       	adc	r25, r25
     ddc:	88 0f       	add	r24, r24
     dde:	99 1f       	adc	r25, r25
     de0:	88 0f       	add	r24, r24
     de2:	99 1f       	adc	r25, r25
     de4:	82 0f       	add	r24, r18
     de6:	93 1f       	adc	r25, r19
     de8:	8f 54       	subi	r24, 0x4F	; 79
     dea:	9b 4f       	sbci	r25, 0xFB	; 251
     dec:	0e 94 bd 01 	call	0x37a	; 0x37a <vListInsertEnd>
     df0:	0f 90       	pop	r0
     df2:	0f be       	out	0x3f, r0	; 63
     df4:	80 91 7a 04 	lds	r24, 0x047A	; 0x80047a <xSchedulerRunning>
     df8:	88 23       	and	r24, r24
     dfa:	21 f0       	breq	.+8      	; 0xe04 <prvAddNewTaskToReadyList+0xa6>
     dfc:	80 91 02 05 	lds	r24, 0x0502	; 0x800502 <pxCurrentTCB>
     e00:	90 91 03 05 	lds	r25, 0x0503	; 0x800503 <pxCurrentTCB+0x1>
     e04:	df 91       	pop	r29
     e06:	cf 91       	pop	r28
     e08:	08 95       	ret

00000e0a <prvAddCurrentTaskToDelayedList>:
     e0a:	ff 92       	push	r15
     e0c:	0f 93       	push	r16
     e0e:	1f 93       	push	r17
     e10:	cf 93       	push	r28
     e12:	df 93       	push	r29
     e14:	ec 01       	movw	r28, r24
     e16:	f6 2e       	mov	r15, r22
     e18:	00 91 7c 04 	lds	r16, 0x047C	; 0x80047c <xTickCount>
     e1c:	10 91 7d 04 	lds	r17, 0x047D	; 0x80047d <xTickCount+0x1>
     e20:	80 91 02 05 	lds	r24, 0x0502	; 0x800502 <pxCurrentTCB>
     e24:	90 91 03 05 	lds	r25, 0x0503	; 0x800503 <pxCurrentTCB+0x1>
     e28:	02 96       	adiw	r24, 0x02	; 2
     e2a:	0e 94 0f 02 	call	0x41e	; 0x41e <uxListRemove>
     e2e:	cf 3f       	cpi	r28, 0xFF	; 255
     e30:	8f ef       	ldi	r24, 0xFF	; 255
     e32:	d8 07       	cpc	r29, r24
     e34:	69 f4       	brne	.+26     	; 0xe50 <prvAddCurrentTaskToDelayedList+0x46>
     e36:	ff 20       	and	r15, r15
     e38:	59 f0       	breq	.+22     	; 0xe50 <prvAddCurrentTaskToDelayedList+0x46>
     e3a:	60 91 02 05 	lds	r22, 0x0502	; 0x800502 <pxCurrentTCB>
     e3e:	70 91 03 05 	lds	r23, 0x0503	; 0x800503 <pxCurrentTCB+0x1>
     e42:	6e 5f       	subi	r22, 0xFE	; 254
     e44:	7f 4f       	sbci	r23, 0xFF	; 255
     e46:	8f e7       	ldi	r24, 0x7F	; 127
     e48:	94 e0       	ldi	r25, 0x04	; 4
     e4a:	0e 94 bd 01 	call	0x37a	; 0x37a <vListInsertEnd>
     e4e:	2f c0       	rjmp	.+94     	; 0xeae <prvAddCurrentTaskToDelayedList+0xa4>
     e50:	c0 0f       	add	r28, r16
     e52:	d1 1f       	adc	r29, r17
     e54:	e0 91 02 05 	lds	r30, 0x0502	; 0x800502 <pxCurrentTCB>
     e58:	f0 91 03 05 	lds	r31, 0x0503	; 0x800503 <pxCurrentTCB+0x1>
     e5c:	d3 83       	std	Z+3, r29	; 0x03
     e5e:	c2 83       	std	Z+2, r28	; 0x02
     e60:	c0 17       	cp	r28, r16
     e62:	d1 07       	cpc	r29, r17
     e64:	68 f4       	brcc	.+26     	; 0xe80 <prvAddCurrentTaskToDelayedList+0x76>
     e66:	60 91 02 05 	lds	r22, 0x0502	; 0x800502 <pxCurrentTCB>
     e6a:	70 91 03 05 	lds	r23, 0x0503	; 0x800503 <pxCurrentTCB+0x1>
     e6e:	80 91 9b 04 	lds	r24, 0x049B	; 0x80049b <pxOverflowDelayedTaskList>
     e72:	90 91 9c 04 	lds	r25, 0x049C	; 0x80049c <pxOverflowDelayedTaskList+0x1>
     e76:	6e 5f       	subi	r22, 0xFE	; 254
     e78:	7f 4f       	sbci	r23, 0xFF	; 255
     e7a:	0e 94 de 01 	call	0x3bc	; 0x3bc <vListInsert>
     e7e:	17 c0       	rjmp	.+46     	; 0xeae <prvAddCurrentTaskToDelayedList+0xa4>
     e80:	60 91 02 05 	lds	r22, 0x0502	; 0x800502 <pxCurrentTCB>
     e84:	70 91 03 05 	lds	r23, 0x0503	; 0x800503 <pxCurrentTCB+0x1>
     e88:	80 91 9d 04 	lds	r24, 0x049D	; 0x80049d <pxDelayedTaskList>
     e8c:	90 91 9e 04 	lds	r25, 0x049E	; 0x80049e <pxDelayedTaskList+0x1>
     e90:	6e 5f       	subi	r22, 0xFE	; 254
     e92:	7f 4f       	sbci	r23, 0xFF	; 255
     e94:	0e 94 de 01 	call	0x3bc	; 0x3bc <vListInsert>
     e98:	80 91 74 04 	lds	r24, 0x0474	; 0x800474 <xNextTaskUnblockTime>
     e9c:	90 91 75 04 	lds	r25, 0x0475	; 0x800475 <xNextTaskUnblockTime+0x1>
     ea0:	c8 17       	cp	r28, r24
     ea2:	d9 07       	cpc	r29, r25
     ea4:	20 f4       	brcc	.+8      	; 0xeae <prvAddCurrentTaskToDelayedList+0xa4>
     ea6:	d0 93 75 04 	sts	0x0475, r29	; 0x800475 <xNextTaskUnblockTime+0x1>
     eaa:	c0 93 74 04 	sts	0x0474, r28	; 0x800474 <xNextTaskUnblockTime>
     eae:	df 91       	pop	r29
     eb0:	cf 91       	pop	r28
     eb2:	1f 91       	pop	r17
     eb4:	0f 91       	pop	r16
     eb6:	ff 90       	pop	r15
     eb8:	08 95       	ret

00000eba <xTaskCreate>:
     eba:	2f 92       	push	r2
     ebc:	3f 92       	push	r3
     ebe:	4f 92       	push	r4
     ec0:	5f 92       	push	r5
     ec2:	6f 92       	push	r6
     ec4:	7f 92       	push	r7
     ec6:	8f 92       	push	r8
     ec8:	9f 92       	push	r9
     eca:	af 92       	push	r10
     ecc:	bf 92       	push	r11
     ece:	cf 92       	push	r12
     ed0:	df 92       	push	r13
     ed2:	ef 92       	push	r14
     ed4:	ff 92       	push	r15
     ed6:	0f 93       	push	r16
     ed8:	1f 93       	push	r17
     eda:	cf 93       	push	r28
     edc:	df 93       	push	r29
     ede:	3c 01       	movw	r6, r24
     ee0:	1b 01       	movw	r2, r22
     ee2:	5a 01       	movw	r10, r20
     ee4:	29 01       	movw	r4, r18
     ee6:	ca 01       	movw	r24, r20
     ee8:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <pvPortMalloc>
     eec:	6c 01       	movw	r12, r24
     eee:	89 2b       	or	r24, r25
     ef0:	71 f0       	breq	.+28     	; 0xf0e <xTaskCreate+0x54>
     ef2:	88 e2       	ldi	r24, 0x28	; 40
     ef4:	90 e0       	ldi	r25, 0x00	; 0
     ef6:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <pvPortMalloc>
     efa:	ec 01       	movw	r28, r24
     efc:	89 2b       	or	r24, r25
     efe:	19 f0       	breq	.+6      	; 0xf06 <xTaskCreate+0x4c>
     f00:	d8 8e       	std	Y+24, r13	; 0x18
     f02:	cf 8a       	std	Y+23, r12	; 0x17
     f04:	06 c0       	rjmp	.+12     	; 0xf12 <xTaskCreate+0x58>
     f06:	c6 01       	movw	r24, r12
     f08:	0e 94 78 01 	call	0x2f0	; 0x2f0 <vPortFree>
     f0c:	02 c0       	rjmp	.+4      	; 0xf12 <xTaskCreate+0x58>
     f0e:	c0 e0       	ldi	r28, 0x00	; 0
     f10:	d0 e0       	ldi	r29, 0x00	; 0
     f12:	20 97       	sbiw	r28, 0x00	; 0
     f14:	91 f0       	breq	.+36     	; 0xf3a <xTaskCreate+0x80>
     f16:	95 01       	movw	r18, r10
     f18:	40 e0       	ldi	r20, 0x00	; 0
     f1a:	50 e0       	ldi	r21, 0x00	; 0
     f1c:	81 2c       	mov	r8, r1
     f1e:	91 2c       	mov	r9, r1
     f20:	5e 01       	movw	r10, r28
     f22:	67 01       	movw	r12, r14
     f24:	e0 2e       	mov	r14, r16
     f26:	82 01       	movw	r16, r4
     f28:	b1 01       	movw	r22, r2
     f2a:	c3 01       	movw	r24, r6
     f2c:	0e 94 0d 06 	call	0xc1a	; 0xc1a <prvInitialiseNewTask>
     f30:	ce 01       	movw	r24, r28
     f32:	0e 94 af 06 	call	0xd5e	; 0xd5e <prvAddNewTaskToReadyList>
     f36:	81 e0       	ldi	r24, 0x01	; 1
     f38:	01 c0       	rjmp	.+2      	; 0xf3c <xTaskCreate+0x82>
     f3a:	8f ef       	ldi	r24, 0xFF	; 255
     f3c:	df 91       	pop	r29
     f3e:	cf 91       	pop	r28
     f40:	1f 91       	pop	r17
     f42:	0f 91       	pop	r16
     f44:	ff 90       	pop	r15
     f46:	ef 90       	pop	r14
     f48:	df 90       	pop	r13
     f4a:	cf 90       	pop	r12
     f4c:	bf 90       	pop	r11
     f4e:	af 90       	pop	r10
     f50:	9f 90       	pop	r9
     f52:	8f 90       	pop	r8
     f54:	7f 90       	pop	r7
     f56:	6f 90       	pop	r6
     f58:	5f 90       	pop	r5
     f5a:	4f 90       	pop	r4
     f5c:	3f 90       	pop	r3
     f5e:	2f 90       	pop	r2
     f60:	08 95       	ret

00000f62 <vTaskStartScheduler>:
     f62:	ef 92       	push	r14
     f64:	ff 92       	push	r15
     f66:	0f 93       	push	r16
     f68:	0f 2e       	mov	r0, r31
     f6a:	f2 e7       	ldi	r31, 0x72	; 114
     f6c:	ef 2e       	mov	r14, r31
     f6e:	f4 e0       	ldi	r31, 0x04	; 4
     f70:	ff 2e       	mov	r15, r31
     f72:	f0 2d       	mov	r31, r0
     f74:	00 e0       	ldi	r16, 0x00	; 0
     f76:	20 e0       	ldi	r18, 0x00	; 0
     f78:	30 e0       	ldi	r19, 0x00	; 0
     f7a:	40 e5       	ldi	r20, 0x50	; 80
     f7c:	50 e0       	ldi	r21, 0x00	; 0
     f7e:	62 e6       	ldi	r22, 0x62	; 98
     f80:	70 e0       	ldi	r23, 0x00	; 0
     f82:	89 e1       	ldi	r24, 0x19	; 25
     f84:	99 e0       	ldi	r25, 0x09	; 9
     f86:	0e 94 5d 07 	call	0xeba	; 0xeba <xTaskCreate>
     f8a:	81 30       	cpi	r24, 0x01	; 1
     f8c:	81 f4       	brne	.+32     	; 0xfae <vTaskStartScheduler+0x4c>
     f8e:	f8 94       	cli
     f90:	8f ef       	ldi	r24, 0xFF	; 255
     f92:	9f ef       	ldi	r25, 0xFF	; 255
     f94:	90 93 75 04 	sts	0x0475, r25	; 0x800475 <xNextTaskUnblockTime+0x1>
     f98:	80 93 74 04 	sts	0x0474, r24	; 0x800474 <xNextTaskUnblockTime>
     f9c:	81 e0       	ldi	r24, 0x01	; 1
     f9e:	80 93 7a 04 	sts	0x047A, r24	; 0x80047a <xSchedulerRunning>
     fa2:	10 92 7d 04 	sts	0x047D, r1	; 0x80047d <xTickCount+0x1>
     fa6:	10 92 7c 04 	sts	0x047C, r1	; 0x80047c <xTickCount>
     faa:	0e 94 aa 02 	call	0x554	; 0x554 <xPortStartScheduler>
     fae:	0f 91       	pop	r16
     fb0:	ff 90       	pop	r15
     fb2:	ef 90       	pop	r14
     fb4:	08 95       	ret

00000fb6 <vTaskSuspendAll>:
     fb6:	80 91 71 04 	lds	r24, 0x0471	; 0x800471 <uxSchedulerSuspended>
     fba:	8f 5f       	subi	r24, 0xFF	; 255
     fbc:	80 93 71 04 	sts	0x0471, r24	; 0x800471 <uxSchedulerSuspended>
     fc0:	08 95       	ret

00000fc2 <xTaskIncrementTick>:
     fc2:	ef 92       	push	r14
     fc4:	ff 92       	push	r15
     fc6:	0f 93       	push	r16
     fc8:	1f 93       	push	r17
     fca:	cf 93       	push	r28
     fcc:	df 93       	push	r29
     fce:	80 91 71 04 	lds	r24, 0x0471	; 0x800471 <uxSchedulerSuspended>
     fd2:	81 11       	cpse	r24, r1
     fd4:	73 c0       	rjmp	.+230    	; 0x10bc <xTaskIncrementTick+0xfa>
     fd6:	e0 90 7c 04 	lds	r14, 0x047C	; 0x80047c <xTickCount>
     fda:	f0 90 7d 04 	lds	r15, 0x047D	; 0x80047d <xTickCount+0x1>
     fde:	8f ef       	ldi	r24, 0xFF	; 255
     fe0:	e8 1a       	sub	r14, r24
     fe2:	f8 0a       	sbc	r15, r24
     fe4:	f0 92 7d 04 	sts	0x047D, r15	; 0x80047d <xTickCount+0x1>
     fe8:	e0 92 7c 04 	sts	0x047C, r14	; 0x80047c <xTickCount>
     fec:	e1 14       	cp	r14, r1
     fee:	f1 04       	cpc	r15, r1
     ff0:	b9 f4       	brne	.+46     	; 0x1020 <xTaskIncrementTick+0x5e>
     ff2:	80 91 9d 04 	lds	r24, 0x049D	; 0x80049d <pxDelayedTaskList>
     ff6:	90 91 9e 04 	lds	r25, 0x049E	; 0x80049e <pxDelayedTaskList+0x1>
     ffa:	20 91 9b 04 	lds	r18, 0x049B	; 0x80049b <pxOverflowDelayedTaskList>
     ffe:	30 91 9c 04 	lds	r19, 0x049C	; 0x80049c <pxOverflowDelayedTaskList+0x1>
    1002:	30 93 9e 04 	sts	0x049E, r19	; 0x80049e <pxDelayedTaskList+0x1>
    1006:	20 93 9d 04 	sts	0x049D, r18	; 0x80049d <pxDelayedTaskList>
    100a:	90 93 9c 04 	sts	0x049C, r25	; 0x80049c <pxOverflowDelayedTaskList+0x1>
    100e:	80 93 9b 04 	sts	0x049B, r24	; 0x80049b <pxOverflowDelayedTaskList>
    1012:	80 91 77 04 	lds	r24, 0x0477	; 0x800477 <xNumOfOverflows>
    1016:	8f 5f       	subi	r24, 0xFF	; 255
    1018:	80 93 77 04 	sts	0x0477, r24	; 0x800477 <xNumOfOverflows>
    101c:	0e 94 e1 05 	call	0xbc2	; 0xbc2 <prvResetNextTaskUnblockTime>
    1020:	80 91 74 04 	lds	r24, 0x0474	; 0x800474 <xNextTaskUnblockTime>
    1024:	90 91 75 04 	lds	r25, 0x0475	; 0x800475 <xNextTaskUnblockTime+0x1>
    1028:	e8 16       	cp	r14, r24
    102a:	f9 06       	cpc	r15, r25
    102c:	08 f4       	brcc	.+2      	; 0x1030 <xTaskIncrementTick+0x6e>
    102e:	4b c0       	rjmp	.+150    	; 0x10c6 <xTaskIncrementTick+0x104>
    1030:	e0 91 9d 04 	lds	r30, 0x049D	; 0x80049d <pxDelayedTaskList>
    1034:	f0 91 9e 04 	lds	r31, 0x049E	; 0x80049e <pxDelayedTaskList+0x1>
    1038:	80 81       	ld	r24, Z
    103a:	81 11       	cpse	r24, r1
    103c:	07 c0       	rjmp	.+14     	; 0x104c <xTaskIncrementTick+0x8a>
    103e:	8f ef       	ldi	r24, 0xFF	; 255
    1040:	9f ef       	ldi	r25, 0xFF	; 255
    1042:	90 93 75 04 	sts	0x0475, r25	; 0x800475 <xNextTaskUnblockTime+0x1>
    1046:	80 93 74 04 	sts	0x0474, r24	; 0x800474 <xNextTaskUnblockTime>
    104a:	3d c0       	rjmp	.+122    	; 0x10c6 <xTaskIncrementTick+0x104>
    104c:	e0 91 9d 04 	lds	r30, 0x049D	; 0x80049d <pxDelayedTaskList>
    1050:	f0 91 9e 04 	lds	r31, 0x049E	; 0x80049e <pxDelayedTaskList+0x1>
    1054:	05 80       	ldd	r0, Z+5	; 0x05
    1056:	f6 81       	ldd	r31, Z+6	; 0x06
    1058:	e0 2d       	mov	r30, r0
    105a:	c6 81       	ldd	r28, Z+6	; 0x06
    105c:	d7 81       	ldd	r29, Z+7	; 0x07
    105e:	8a 81       	ldd	r24, Y+2	; 0x02
    1060:	9b 81       	ldd	r25, Y+3	; 0x03
    1062:	e8 16       	cp	r14, r24
    1064:	f9 06       	cpc	r15, r25
    1066:	28 f4       	brcc	.+10     	; 0x1072 <xTaskIncrementTick+0xb0>
    1068:	90 93 75 04 	sts	0x0475, r25	; 0x800475 <xNextTaskUnblockTime+0x1>
    106c:	80 93 74 04 	sts	0x0474, r24	; 0x800474 <xNextTaskUnblockTime>
    1070:	2a c0       	rjmp	.+84     	; 0x10c6 <xTaskIncrementTick+0x104>
    1072:	8e 01       	movw	r16, r28
    1074:	0e 5f       	subi	r16, 0xFE	; 254
    1076:	1f 4f       	sbci	r17, 0xFF	; 255
    1078:	c8 01       	movw	r24, r16
    107a:	0e 94 0f 02 	call	0x41e	; 0x41e <uxListRemove>
    107e:	8c 89       	ldd	r24, Y+20	; 0x14
    1080:	9d 89       	ldd	r25, Y+21	; 0x15
    1082:	89 2b       	or	r24, r25
    1084:	21 f0       	breq	.+8      	; 0x108e <xTaskIncrementTick+0xcc>
    1086:	ce 01       	movw	r24, r28
    1088:	0c 96       	adiw	r24, 0x0c	; 12
    108a:	0e 94 0f 02 	call	0x41e	; 0x41e <uxListRemove>
    108e:	8e 89       	ldd	r24, Y+22	; 0x16
    1090:	90 91 7b 04 	lds	r25, 0x047B	; 0x80047b <uxTopReadyPriority>
    1094:	98 17       	cp	r25, r24
    1096:	10 f4       	brcc	.+4      	; 0x109c <xTaskIncrementTick+0xda>
    1098:	80 93 7b 04 	sts	0x047B, r24	; 0x80047b <uxTopReadyPriority>
    109c:	90 e0       	ldi	r25, 0x00	; 0
    109e:	9c 01       	movw	r18, r24
    10a0:	22 0f       	add	r18, r18
    10a2:	33 1f       	adc	r19, r19
    10a4:	22 0f       	add	r18, r18
    10a6:	33 1f       	adc	r19, r19
    10a8:	22 0f       	add	r18, r18
    10aa:	33 1f       	adc	r19, r19
    10ac:	82 0f       	add	r24, r18
    10ae:	93 1f       	adc	r25, r19
    10b0:	b8 01       	movw	r22, r16
    10b2:	8f 54       	subi	r24, 0x4F	; 79
    10b4:	9b 4f       	sbci	r25, 0xFB	; 251
    10b6:	0e 94 bd 01 	call	0x37a	; 0x37a <vListInsertEnd>
    10ba:	ba cf       	rjmp	.-140    	; 0x1030 <xTaskIncrementTick+0x6e>
    10bc:	80 91 79 04 	lds	r24, 0x0479	; 0x800479 <uxPendedTicks>
    10c0:	8f 5f       	subi	r24, 0xFF	; 255
    10c2:	80 93 79 04 	sts	0x0479, r24	; 0x800479 <uxPendedTicks>
    10c6:	80 e0       	ldi	r24, 0x00	; 0
    10c8:	df 91       	pop	r29
    10ca:	cf 91       	pop	r28
    10cc:	1f 91       	pop	r17
    10ce:	0f 91       	pop	r16
    10d0:	ff 90       	pop	r15
    10d2:	ef 90       	pop	r14
    10d4:	08 95       	ret

000010d6 <xTaskResumeAll>:
    10d6:	0f 93       	push	r16
    10d8:	1f 93       	push	r17
    10da:	cf 93       	push	r28
    10dc:	df 93       	push	r29
    10de:	0f b6       	in	r0, 0x3f	; 63
    10e0:	f8 94       	cli
    10e2:	0f 92       	push	r0
    10e4:	80 91 71 04 	lds	r24, 0x0471	; 0x800471 <uxSchedulerSuspended>
    10e8:	81 50       	subi	r24, 0x01	; 1
    10ea:	80 93 71 04 	sts	0x0471, r24	; 0x800471 <uxSchedulerSuspended>
    10ee:	80 91 71 04 	lds	r24, 0x0471	; 0x800471 <uxSchedulerSuspended>
    10f2:	81 11       	cpse	r24, r1
    10f4:	52 c0       	rjmp	.+164    	; 0x119a <xTaskResumeAll+0xc4>
    10f6:	80 91 7e 04 	lds	r24, 0x047E	; 0x80047e <uxCurrentNumberOfTasks>
    10fa:	81 11       	cpse	r24, r1
    10fc:	33 c0       	rjmp	.+102    	; 0x1164 <xTaskResumeAll+0x8e>
    10fe:	4d c0       	rjmp	.+154    	; 0x119a <xTaskResumeAll+0xc4>
    1100:	e0 91 97 04 	lds	r30, 0x0497	; 0x800497 <xPendingReadyList+0x5>
    1104:	f0 91 98 04 	lds	r31, 0x0498	; 0x800498 <xPendingReadyList+0x6>
    1108:	c6 81       	ldd	r28, Z+6	; 0x06
    110a:	d7 81       	ldd	r29, Z+7	; 0x07
    110c:	ce 01       	movw	r24, r28
    110e:	0c 96       	adiw	r24, 0x0c	; 12
    1110:	0e 94 0f 02 	call	0x41e	; 0x41e <uxListRemove>
    1114:	8e 01       	movw	r16, r28
    1116:	0e 5f       	subi	r16, 0xFE	; 254
    1118:	1f 4f       	sbci	r17, 0xFF	; 255
    111a:	c8 01       	movw	r24, r16
    111c:	0e 94 0f 02 	call	0x41e	; 0x41e <uxListRemove>
    1120:	8e 89       	ldd	r24, Y+22	; 0x16
    1122:	90 91 7b 04 	lds	r25, 0x047B	; 0x80047b <uxTopReadyPriority>
    1126:	98 17       	cp	r25, r24
    1128:	10 f4       	brcc	.+4      	; 0x112e <xTaskResumeAll+0x58>
    112a:	80 93 7b 04 	sts	0x047B, r24	; 0x80047b <uxTopReadyPriority>
    112e:	90 e0       	ldi	r25, 0x00	; 0
    1130:	9c 01       	movw	r18, r24
    1132:	22 0f       	add	r18, r18
    1134:	33 1f       	adc	r19, r19
    1136:	22 0f       	add	r18, r18
    1138:	33 1f       	adc	r19, r19
    113a:	22 0f       	add	r18, r18
    113c:	33 1f       	adc	r19, r19
    113e:	82 0f       	add	r24, r18
    1140:	93 1f       	adc	r25, r19
    1142:	b8 01       	movw	r22, r16
    1144:	8f 54       	subi	r24, 0x4F	; 79
    1146:	9b 4f       	sbci	r25, 0xFB	; 251
    1148:	0e 94 bd 01 	call	0x37a	; 0x37a <vListInsertEnd>
    114c:	9e 89       	ldd	r25, Y+22	; 0x16
    114e:	e0 91 02 05 	lds	r30, 0x0502	; 0x800502 <pxCurrentTCB>
    1152:	f0 91 03 05 	lds	r31, 0x0503	; 0x800503 <pxCurrentTCB+0x1>
    1156:	86 89       	ldd	r24, Z+22	; 0x16
    1158:	98 17       	cp	r25, r24
    115a:	30 f0       	brcs	.+12     	; 0x1168 <xTaskResumeAll+0x92>
    115c:	81 e0       	ldi	r24, 0x01	; 1
    115e:	80 93 78 04 	sts	0x0478, r24	; 0x800478 <xYieldPending>
    1162:	02 c0       	rjmp	.+4      	; 0x1168 <xTaskResumeAll+0x92>
    1164:	c0 e0       	ldi	r28, 0x00	; 0
    1166:	d0 e0       	ldi	r29, 0x00	; 0
    1168:	80 91 92 04 	lds	r24, 0x0492	; 0x800492 <xPendingReadyList>
    116c:	81 11       	cpse	r24, r1
    116e:	c8 cf       	rjmp	.-112    	; 0x1100 <xTaskResumeAll+0x2a>
    1170:	cd 2b       	or	r28, r29
    1172:	11 f0       	breq	.+4      	; 0x1178 <xTaskResumeAll+0xa2>
    1174:	0e 94 e1 05 	call	0xbc2	; 0xbc2 <prvResetNextTaskUnblockTime>
    1178:	c0 91 79 04 	lds	r28, 0x0479	; 0x800479 <uxPendedTicks>
    117c:	cc 23       	and	r28, r28
    117e:	59 f0       	breq	.+22     	; 0x1196 <xTaskResumeAll+0xc0>
    1180:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <xTaskIncrementTick>
    1184:	88 23       	and	r24, r24
    1186:	19 f0       	breq	.+6      	; 0x118e <xTaskResumeAll+0xb8>
    1188:	81 e0       	ldi	r24, 0x01	; 1
    118a:	80 93 78 04 	sts	0x0478, r24	; 0x800478 <xYieldPending>
    118e:	c1 50       	subi	r28, 0x01	; 1
    1190:	b9 f7       	brne	.-18     	; 0x1180 <xTaskResumeAll+0xaa>
    1192:	10 92 79 04 	sts	0x0479, r1	; 0x800479 <uxPendedTicks>
    1196:	80 91 78 04 	lds	r24, 0x0478	; 0x800478 <xYieldPending>
    119a:	0f 90       	pop	r0
    119c:	0f be       	out	0x3f, r0	; 63
    119e:	80 e0       	ldi	r24, 0x00	; 0
    11a0:	df 91       	pop	r29
    11a2:	cf 91       	pop	r28
    11a4:	1f 91       	pop	r17
    11a6:	0f 91       	pop	r16
    11a8:	08 95       	ret

000011aa <vTaskDelay>:
    11aa:	cf 93       	push	r28
    11ac:	df 93       	push	r29
    11ae:	ec 01       	movw	r28, r24
    11b0:	89 2b       	or	r24, r25
    11b2:	49 f0       	breq	.+18     	; 0x11c6 <vTaskDelay+0x1c>
    11b4:	0e 94 db 07 	call	0xfb6	; 0xfb6 <vTaskSuspendAll>
    11b8:	60 e0       	ldi	r22, 0x00	; 0
    11ba:	ce 01       	movw	r24, r28
    11bc:	0e 94 05 07 	call	0xe0a	; 0xe0a <prvAddCurrentTaskToDelayedList>
    11c0:	0e 94 6b 08 	call	0x10d6	; 0x10d6 <xTaskResumeAll>
    11c4:	01 c0       	rjmp	.+2      	; 0x11c8 <vTaskDelay+0x1e>
    11c6:	80 e0       	ldi	r24, 0x00	; 0
    11c8:	81 11       	cpse	r24, r1
    11ca:	02 c0       	rjmp	.+4      	; 0x11d0 <vTaskDelay+0x26>
    11cc:	0e 94 d9 02 	call	0x5b2	; 0x5b2 <vPortYield>
    11d0:	df 91       	pop	r29
    11d2:	cf 91       	pop	r28
    11d4:	08 95       	ret

000011d6 <prvCheckTasksWaitingTermination>:
    11d6:	cf 93       	push	r28
    11d8:	df 93       	push	r29
    11da:	24 c0       	rjmp	.+72     	; 0x1224 <prvCheckTasksWaitingTermination+0x4e>
    11dc:	0e 94 db 07 	call	0xfb6	; 0xfb6 <vTaskSuspendAll>
    11e0:	c0 91 89 04 	lds	r28, 0x0489	; 0x800489 <xTasksWaitingTermination>
    11e4:	0e 94 6b 08 	call	0x10d6	; 0x10d6 <xTaskResumeAll>
    11e8:	cc 23       	and	r28, r28
    11ea:	e1 f0       	breq	.+56     	; 0x1224 <prvCheckTasksWaitingTermination+0x4e>
    11ec:	0f b6       	in	r0, 0x3f	; 63
    11ee:	f8 94       	cli
    11f0:	0f 92       	push	r0
    11f2:	e0 91 8e 04 	lds	r30, 0x048E	; 0x80048e <xTasksWaitingTermination+0x5>
    11f6:	f0 91 8f 04 	lds	r31, 0x048F	; 0x80048f <xTasksWaitingTermination+0x6>
    11fa:	c6 81       	ldd	r28, Z+6	; 0x06
    11fc:	d7 81       	ldd	r29, Z+7	; 0x07
    11fe:	ce 01       	movw	r24, r28
    1200:	02 96       	adiw	r24, 0x02	; 2
    1202:	0e 94 0f 02 	call	0x41e	; 0x41e <uxListRemove>
    1206:	80 91 7e 04 	lds	r24, 0x047E	; 0x80047e <uxCurrentNumberOfTasks>
    120a:	81 50       	subi	r24, 0x01	; 1
    120c:	80 93 7e 04 	sts	0x047E, r24	; 0x80047e <uxCurrentNumberOfTasks>
    1210:	80 91 88 04 	lds	r24, 0x0488	; 0x800488 <uxDeletedTasksWaitingCleanUp>
    1214:	81 50       	subi	r24, 0x01	; 1
    1216:	80 93 88 04 	sts	0x0488, r24	; 0x800488 <uxDeletedTasksWaitingCleanUp>
    121a:	0f 90       	pop	r0
    121c:	0f be       	out	0x3f, r0	; 63
    121e:	ce 01       	movw	r24, r28
    1220:	0e 94 00 06 	call	0xc00	; 0xc00 <prvDeleteTCB>
    1224:	80 91 88 04 	lds	r24, 0x0488	; 0x800488 <uxDeletedTasksWaitingCleanUp>
    1228:	81 11       	cpse	r24, r1
    122a:	d8 cf       	rjmp	.-80     	; 0x11dc <prvCheckTasksWaitingTermination+0x6>
    122c:	df 91       	pop	r29
    122e:	cf 91       	pop	r28
    1230:	08 95       	ret

00001232 <prvIdleTask>:
    1232:	0e 94 eb 08 	call	0x11d6	; 0x11d6 <prvCheckTasksWaitingTermination>
    1236:	0e 94 d9 02 	call	0x5b2	; 0x5b2 <vPortYield>
    123a:	fb cf       	rjmp	.-10     	; 0x1232 <prvIdleTask>

0000123c <vTaskSwitchContext>:
    123c:	80 91 71 04 	lds	r24, 0x0471	; 0x800471 <uxSchedulerSuspended>
    1240:	88 23       	and	r24, r24
    1242:	21 f0       	breq	.+8      	; 0x124c <vTaskSwitchContext+0x10>
    1244:	81 e0       	ldi	r24, 0x01	; 1
    1246:	80 93 78 04 	sts	0x0478, r24	; 0x800478 <xYieldPending>
    124a:	08 95       	ret
    124c:	10 92 78 04 	sts	0x0478, r1	; 0x800478 <xYieldPending>
    1250:	20 91 7b 04 	lds	r18, 0x047B	; 0x80047b <uxTopReadyPriority>
    1254:	01 c0       	rjmp	.+2      	; 0x1258 <vTaskSwitchContext+0x1c>
    1256:	21 50       	subi	r18, 0x01	; 1
    1258:	82 2f       	mov	r24, r18
    125a:	90 e0       	ldi	r25, 0x00	; 0
    125c:	fc 01       	movw	r30, r24
    125e:	ee 0f       	add	r30, r30
    1260:	ff 1f       	adc	r31, r31
    1262:	ee 0f       	add	r30, r30
    1264:	ff 1f       	adc	r31, r31
    1266:	ee 0f       	add	r30, r30
    1268:	ff 1f       	adc	r31, r31
    126a:	e8 0f       	add	r30, r24
    126c:	f9 1f       	adc	r31, r25
    126e:	ef 54       	subi	r30, 0x4F	; 79
    1270:	fb 4f       	sbci	r31, 0xFB	; 251
    1272:	30 81       	ld	r19, Z
    1274:	33 23       	and	r19, r19
    1276:	79 f3       	breq	.-34     	; 0x1256 <vTaskSwitchContext+0x1a>
    1278:	ac 01       	movw	r20, r24
    127a:	44 0f       	add	r20, r20
    127c:	55 1f       	adc	r21, r21
    127e:	44 0f       	add	r20, r20
    1280:	55 1f       	adc	r21, r21
    1282:	44 0f       	add	r20, r20
    1284:	55 1f       	adc	r21, r21
    1286:	48 0f       	add	r20, r24
    1288:	59 1f       	adc	r21, r25
    128a:	df 01       	movw	r26, r30
    128c:	01 80       	ldd	r0, Z+1	; 0x01
    128e:	f2 81       	ldd	r31, Z+2	; 0x02
    1290:	e0 2d       	mov	r30, r0
    1292:	02 80       	ldd	r0, Z+2	; 0x02
    1294:	f3 81       	ldd	r31, Z+3	; 0x03
    1296:	e0 2d       	mov	r30, r0
    1298:	12 96       	adiw	r26, 0x02	; 2
    129a:	fc 93       	st	X, r31
    129c:	ee 93       	st	-X, r30
    129e:	11 97       	sbiw	r26, 0x01	; 1
    12a0:	4c 54       	subi	r20, 0x4C	; 76
    12a2:	5b 4f       	sbci	r21, 0xFB	; 251
    12a4:	e4 17       	cp	r30, r20
    12a6:	f5 07       	cpc	r31, r21
    12a8:	29 f4       	brne	.+10     	; 0x12b4 <vTaskSwitchContext+0x78>
    12aa:	42 81       	ldd	r20, Z+2	; 0x02
    12ac:	53 81       	ldd	r21, Z+3	; 0x03
    12ae:	fd 01       	movw	r30, r26
    12b0:	52 83       	std	Z+2, r21	; 0x02
    12b2:	41 83       	std	Z+1, r20	; 0x01
    12b4:	fc 01       	movw	r30, r24
    12b6:	ee 0f       	add	r30, r30
    12b8:	ff 1f       	adc	r31, r31
    12ba:	ee 0f       	add	r30, r30
    12bc:	ff 1f       	adc	r31, r31
    12be:	ee 0f       	add	r30, r30
    12c0:	ff 1f       	adc	r31, r31
    12c2:	8e 0f       	add	r24, r30
    12c4:	9f 1f       	adc	r25, r31
    12c6:	fc 01       	movw	r30, r24
    12c8:	ef 54       	subi	r30, 0x4F	; 79
    12ca:	fb 4f       	sbci	r31, 0xFB	; 251
    12cc:	01 80       	ldd	r0, Z+1	; 0x01
    12ce:	f2 81       	ldd	r31, Z+2	; 0x02
    12d0:	e0 2d       	mov	r30, r0
    12d2:	86 81       	ldd	r24, Z+6	; 0x06
    12d4:	97 81       	ldd	r25, Z+7	; 0x07
    12d6:	90 93 03 05 	sts	0x0503, r25	; 0x800503 <pxCurrentTCB+0x1>
    12da:	80 93 02 05 	sts	0x0502, r24	; 0x800502 <pxCurrentTCB>
    12de:	20 93 7b 04 	sts	0x047B, r18	; 0x80047b <uxTopReadyPriority>
    12e2:	08 95       	ret

000012e4 <vTaskPlaceOnEventList>:
    12e4:	cf 93       	push	r28
    12e6:	df 93       	push	r29
    12e8:	eb 01       	movw	r28, r22
    12ea:	60 91 02 05 	lds	r22, 0x0502	; 0x800502 <pxCurrentTCB>
    12ee:	70 91 03 05 	lds	r23, 0x0503	; 0x800503 <pxCurrentTCB+0x1>
    12f2:	64 5f       	subi	r22, 0xF4	; 244
    12f4:	7f 4f       	sbci	r23, 0xFF	; 255
    12f6:	0e 94 de 01 	call	0x3bc	; 0x3bc <vListInsert>
    12fa:	61 e0       	ldi	r22, 0x01	; 1
    12fc:	ce 01       	movw	r24, r28
    12fe:	0e 94 05 07 	call	0xe0a	; 0xe0a <prvAddCurrentTaskToDelayedList>
    1302:	df 91       	pop	r29
    1304:	cf 91       	pop	r28
    1306:	08 95       	ret

00001308 <xTaskRemoveFromEventList>:
    1308:	0f 93       	push	r16
    130a:	1f 93       	push	r17
    130c:	cf 93       	push	r28
    130e:	df 93       	push	r29
    1310:	dc 01       	movw	r26, r24
    1312:	15 96       	adiw	r26, 0x05	; 5
    1314:	ed 91       	ld	r30, X+
    1316:	fc 91       	ld	r31, X
    1318:	16 97       	sbiw	r26, 0x06	; 6
    131a:	c6 81       	ldd	r28, Z+6	; 0x06
    131c:	d7 81       	ldd	r29, Z+7	; 0x07
    131e:	8e 01       	movw	r16, r28
    1320:	04 5f       	subi	r16, 0xF4	; 244
    1322:	1f 4f       	sbci	r17, 0xFF	; 255
    1324:	c8 01       	movw	r24, r16
    1326:	0e 94 0f 02 	call	0x41e	; 0x41e <uxListRemove>
    132a:	80 91 71 04 	lds	r24, 0x0471	; 0x800471 <uxSchedulerSuspended>
    132e:	81 11       	cpse	r24, r1
    1330:	1c c0       	rjmp	.+56     	; 0x136a <xTaskRemoveFromEventList+0x62>
    1332:	0a 50       	subi	r16, 0x0A	; 10
    1334:	11 09       	sbc	r17, r1
    1336:	c8 01       	movw	r24, r16
    1338:	0e 94 0f 02 	call	0x41e	; 0x41e <uxListRemove>
    133c:	8e 89       	ldd	r24, Y+22	; 0x16
    133e:	90 91 7b 04 	lds	r25, 0x047B	; 0x80047b <uxTopReadyPriority>
    1342:	98 17       	cp	r25, r24
    1344:	10 f4       	brcc	.+4      	; 0x134a <xTaskRemoveFromEventList+0x42>
    1346:	80 93 7b 04 	sts	0x047B, r24	; 0x80047b <uxTopReadyPriority>
    134a:	90 e0       	ldi	r25, 0x00	; 0
    134c:	9c 01       	movw	r18, r24
    134e:	22 0f       	add	r18, r18
    1350:	33 1f       	adc	r19, r19
    1352:	22 0f       	add	r18, r18
    1354:	33 1f       	adc	r19, r19
    1356:	22 0f       	add	r18, r18
    1358:	33 1f       	adc	r19, r19
    135a:	82 0f       	add	r24, r18
    135c:	93 1f       	adc	r25, r19
    135e:	b8 01       	movw	r22, r16
    1360:	8f 54       	subi	r24, 0x4F	; 79
    1362:	9b 4f       	sbci	r25, 0xFB	; 251
    1364:	0e 94 bd 01 	call	0x37a	; 0x37a <vListInsertEnd>
    1368:	05 c0       	rjmp	.+10     	; 0x1374 <xTaskRemoveFromEventList+0x6c>
    136a:	b8 01       	movw	r22, r16
    136c:	82 e9       	ldi	r24, 0x92	; 146
    136e:	94 e0       	ldi	r25, 0x04	; 4
    1370:	0e 94 bd 01 	call	0x37a	; 0x37a <vListInsertEnd>
    1374:	9e 89       	ldd	r25, Y+22	; 0x16
    1376:	e0 91 02 05 	lds	r30, 0x0502	; 0x800502 <pxCurrentTCB>
    137a:	f0 91 03 05 	lds	r31, 0x0503	; 0x800503 <pxCurrentTCB+0x1>
    137e:	86 89       	ldd	r24, Z+22	; 0x16
    1380:	89 17       	cp	r24, r25
    1382:	20 f4       	brcc	.+8      	; 0x138c <xTaskRemoveFromEventList+0x84>
    1384:	81 e0       	ldi	r24, 0x01	; 1
    1386:	80 93 78 04 	sts	0x0478, r24	; 0x800478 <xYieldPending>
    138a:	01 c0       	rjmp	.+2      	; 0x138e <xTaskRemoveFromEventList+0x86>
    138c:	80 e0       	ldi	r24, 0x00	; 0
    138e:	df 91       	pop	r29
    1390:	cf 91       	pop	r28
    1392:	1f 91       	pop	r17
    1394:	0f 91       	pop	r16
    1396:	08 95       	ret

00001398 <vTaskSetTimeOutState>:
    1398:	20 91 77 04 	lds	r18, 0x0477	; 0x800477 <xNumOfOverflows>
    139c:	fc 01       	movw	r30, r24
    139e:	20 83       	st	Z, r18
    13a0:	20 91 7c 04 	lds	r18, 0x047C	; 0x80047c <xTickCount>
    13a4:	30 91 7d 04 	lds	r19, 0x047D	; 0x80047d <xTickCount+0x1>
    13a8:	32 83       	std	Z+2, r19	; 0x02
    13aa:	21 83       	std	Z+1, r18	; 0x01
    13ac:	08 95       	ret

000013ae <xTaskCheckForTimeOut>:
    13ae:	0f b6       	in	r0, 0x3f	; 63
    13b0:	f8 94       	cli
    13b2:	0f 92       	push	r0
    13b4:	40 91 7c 04 	lds	r20, 0x047C	; 0x80047c <xTickCount>
    13b8:	50 91 7d 04 	lds	r21, 0x047D	; 0x80047d <xTickCount+0x1>
    13bc:	db 01       	movw	r26, r22
    13be:	2d 91       	ld	r18, X+
    13c0:	3c 91       	ld	r19, X
    13c2:	2f 3f       	cpi	r18, 0xFF	; 255
    13c4:	bf ef       	ldi	r27, 0xFF	; 255
    13c6:	3b 07       	cpc	r19, r27
    13c8:	19 f1       	breq	.+70     	; 0x1410 <xTaskCheckForTimeOut+0x62>
    13ca:	dc 01       	movw	r26, r24
    13cc:	fc 91       	ld	r31, X
    13ce:	e0 91 77 04 	lds	r30, 0x0477	; 0x800477 <xNumOfOverflows>
    13d2:	fe 17       	cp	r31, r30
    13d4:	39 f0       	breq	.+14     	; 0x13e4 <xTaskCheckForTimeOut+0x36>
    13d6:	11 96       	adiw	r26, 0x01	; 1
    13d8:	ed 91       	ld	r30, X+
    13da:	fc 91       	ld	r31, X
    13dc:	12 97       	sbiw	r26, 0x02	; 2
    13de:	4e 17       	cp	r20, r30
    13e0:	5f 07       	cpc	r21, r31
    13e2:	c0 f4       	brcc	.+48     	; 0x1414 <xTaskCheckForTimeOut+0x66>
    13e4:	dc 01       	movw	r26, r24
    13e6:	11 96       	adiw	r26, 0x01	; 1
    13e8:	ed 91       	ld	r30, X+
    13ea:	fc 91       	ld	r31, X
    13ec:	12 97       	sbiw	r26, 0x02	; 2
    13ee:	da 01       	movw	r26, r20
    13f0:	ae 1b       	sub	r26, r30
    13f2:	bf 0b       	sbc	r27, r31
    13f4:	a2 17       	cp	r26, r18
    13f6:	b3 07       	cpc	r27, r19
    13f8:	78 f4       	brcc	.+30     	; 0x1418 <xTaskCheckForTimeOut+0x6a>
    13fa:	db 01       	movw	r26, r22
    13fc:	e4 1b       	sub	r30, r20
    13fe:	f5 0b       	sbc	r31, r21
    1400:	2e 0f       	add	r18, r30
    1402:	3f 1f       	adc	r19, r31
    1404:	2d 93       	st	X+, r18
    1406:	3c 93       	st	X, r19
    1408:	0e 94 cc 09 	call	0x1398	; 0x1398 <vTaskSetTimeOutState>
    140c:	80 e0       	ldi	r24, 0x00	; 0
    140e:	05 c0       	rjmp	.+10     	; 0x141a <xTaskCheckForTimeOut+0x6c>
    1410:	80 e0       	ldi	r24, 0x00	; 0
    1412:	03 c0       	rjmp	.+6      	; 0x141a <xTaskCheckForTimeOut+0x6c>
    1414:	81 e0       	ldi	r24, 0x01	; 1
    1416:	01 c0       	rjmp	.+2      	; 0x141a <xTaskCheckForTimeOut+0x6c>
    1418:	81 e0       	ldi	r24, 0x01	; 1
    141a:	0f 90       	pop	r0
    141c:	0f be       	out	0x3f, r0	; 63
    141e:	08 95       	ret

00001420 <vTaskMissedYield>:
    1420:	81 e0       	ldi	r24, 0x01	; 1
    1422:	80 93 78 04 	sts	0x0478, r24	; 0x800478 <xYieldPending>
    1426:	08 95       	ret

00001428 <vTaskPriorityInherit>:
    1428:	0f 93       	push	r16
    142a:	1f 93       	push	r17
    142c:	cf 93       	push	r28
    142e:	df 93       	push	r29
    1430:	fc 01       	movw	r30, r24
    1432:	89 2b       	or	r24, r25
    1434:	09 f4       	brne	.+2      	; 0x1438 <vTaskPriorityInherit+0x10>
    1436:	55 c0       	rjmp	.+170    	; 0x14e2 <vTaskPriorityInherit+0xba>
    1438:	26 89       	ldd	r18, Z+22	; 0x16
    143a:	a0 91 02 05 	lds	r26, 0x0502	; 0x800502 <pxCurrentTCB>
    143e:	b0 91 03 05 	lds	r27, 0x0503	; 0x800503 <pxCurrentTCB+0x1>
    1442:	56 96       	adiw	r26, 0x16	; 22
    1444:	8c 91       	ld	r24, X
    1446:	28 17       	cp	r18, r24
    1448:	08 f0       	brcs	.+2      	; 0x144c <vTaskPriorityInherit+0x24>
    144a:	4b c0       	rjmp	.+150    	; 0x14e2 <vTaskPriorityInherit+0xba>
    144c:	84 85       	ldd	r24, Z+12	; 0x0c
    144e:	95 85       	ldd	r25, Z+13	; 0x0d
    1450:	99 23       	and	r25, r25
    1452:	64 f0       	brlt	.+24     	; 0x146c <vTaskPriorityInherit+0x44>
    1454:	a0 91 02 05 	lds	r26, 0x0502	; 0x800502 <pxCurrentTCB>
    1458:	b0 91 03 05 	lds	r27, 0x0503	; 0x800503 <pxCurrentTCB+0x1>
    145c:	56 96       	adiw	r26, 0x16	; 22
    145e:	3c 91       	ld	r19, X
    1460:	89 e0       	ldi	r24, 0x09	; 9
    1462:	90 e0       	ldi	r25, 0x00	; 0
    1464:	83 1b       	sub	r24, r19
    1466:	91 09       	sbc	r25, r1
    1468:	95 87       	std	Z+13, r25	; 0x0d
    146a:	84 87       	std	Z+12, r24	; 0x0c
    146c:	82 85       	ldd	r24, Z+10	; 0x0a
    146e:	93 85       	ldd	r25, Z+11	; 0x0b
    1470:	30 e0       	ldi	r19, 0x00	; 0
    1472:	a9 01       	movw	r20, r18
    1474:	44 0f       	add	r20, r20
    1476:	55 1f       	adc	r21, r21
    1478:	44 0f       	add	r20, r20
    147a:	55 1f       	adc	r21, r21
    147c:	44 0f       	add	r20, r20
    147e:	55 1f       	adc	r21, r21
    1480:	24 0f       	add	r18, r20
    1482:	35 1f       	adc	r19, r21
    1484:	2f 54       	subi	r18, 0x4F	; 79
    1486:	3b 4f       	sbci	r19, 0xFB	; 251
    1488:	82 17       	cp	r24, r18
    148a:	93 07       	cpc	r25, r19
    148c:	19 f5       	brne	.+70     	; 0x14d4 <vTaskPriorityInherit+0xac>
    148e:	8f 01       	movw	r16, r30
    1490:	ef 01       	movw	r28, r30
    1492:	22 96       	adiw	r28, 0x02	; 2
    1494:	ce 01       	movw	r24, r28
    1496:	0e 94 0f 02 	call	0x41e	; 0x41e <uxListRemove>
    149a:	e0 91 02 05 	lds	r30, 0x0502	; 0x800502 <pxCurrentTCB>
    149e:	f0 91 03 05 	lds	r31, 0x0503	; 0x800503 <pxCurrentTCB+0x1>
    14a2:	86 89       	ldd	r24, Z+22	; 0x16
    14a4:	f8 01       	movw	r30, r16
    14a6:	86 8b       	std	Z+22, r24	; 0x16
    14a8:	90 91 7b 04 	lds	r25, 0x047B	; 0x80047b <uxTopReadyPriority>
    14ac:	98 17       	cp	r25, r24
    14ae:	10 f4       	brcc	.+4      	; 0x14b4 <vTaskPriorityInherit+0x8c>
    14b0:	80 93 7b 04 	sts	0x047B, r24	; 0x80047b <uxTopReadyPriority>
    14b4:	90 e0       	ldi	r25, 0x00	; 0
    14b6:	9c 01       	movw	r18, r24
    14b8:	22 0f       	add	r18, r18
    14ba:	33 1f       	adc	r19, r19
    14bc:	22 0f       	add	r18, r18
    14be:	33 1f       	adc	r19, r19
    14c0:	22 0f       	add	r18, r18
    14c2:	33 1f       	adc	r19, r19
    14c4:	82 0f       	add	r24, r18
    14c6:	93 1f       	adc	r25, r19
    14c8:	be 01       	movw	r22, r28
    14ca:	8f 54       	subi	r24, 0x4F	; 79
    14cc:	9b 4f       	sbci	r25, 0xFB	; 251
    14ce:	0e 94 bd 01 	call	0x37a	; 0x37a <vListInsertEnd>
    14d2:	07 c0       	rjmp	.+14     	; 0x14e2 <vTaskPriorityInherit+0xba>
    14d4:	a0 91 02 05 	lds	r26, 0x0502	; 0x800502 <pxCurrentTCB>
    14d8:	b0 91 03 05 	lds	r27, 0x0503	; 0x800503 <pxCurrentTCB+0x1>
    14dc:	56 96       	adiw	r26, 0x16	; 22
    14de:	8c 91       	ld	r24, X
    14e0:	86 8b       	std	Z+22, r24	; 0x16
    14e2:	df 91       	pop	r29
    14e4:	cf 91       	pop	r28
    14e6:	1f 91       	pop	r17
    14e8:	0f 91       	pop	r16
    14ea:	08 95       	ret

000014ec <xTaskPriorityDisinherit>:
    14ec:	0f 93       	push	r16
    14ee:	1f 93       	push	r17
    14f0:	cf 93       	push	r28
    14f2:	df 93       	push	r29
    14f4:	fc 01       	movw	r30, r24
    14f6:	89 2b       	or	r24, r25
    14f8:	79 f1       	breq	.+94     	; 0x1558 <xTaskPriorityDisinherit+0x6c>
    14fa:	82 a1       	ldd	r24, Z+34	; 0x22
    14fc:	81 50       	subi	r24, 0x01	; 1
    14fe:	82 a3       	std	Z+34, r24	; 0x22
    1500:	26 89       	ldd	r18, Z+22	; 0x16
    1502:	91 a1       	ldd	r25, Z+33	; 0x21
    1504:	29 17       	cp	r18, r25
    1506:	51 f1       	breq	.+84     	; 0x155c <xTaskPriorityDisinherit+0x70>
    1508:	81 11       	cpse	r24, r1
    150a:	2a c0       	rjmp	.+84     	; 0x1560 <xTaskPriorityDisinherit+0x74>
    150c:	ef 01       	movw	r28, r30
    150e:	8f 01       	movw	r16, r30
    1510:	0e 5f       	subi	r16, 0xFE	; 254
    1512:	1f 4f       	sbci	r17, 0xFF	; 255
    1514:	c8 01       	movw	r24, r16
    1516:	0e 94 0f 02 	call	0x41e	; 0x41e <uxListRemove>
    151a:	89 a1       	ldd	r24, Y+33	; 0x21
    151c:	8e 8b       	std	Y+22, r24	; 0x16
    151e:	29 e0       	ldi	r18, 0x09	; 9
    1520:	30 e0       	ldi	r19, 0x00	; 0
    1522:	28 1b       	sub	r18, r24
    1524:	31 09       	sbc	r19, r1
    1526:	3d 87       	std	Y+13, r19	; 0x0d
    1528:	2c 87       	std	Y+12, r18	; 0x0c
    152a:	90 91 7b 04 	lds	r25, 0x047B	; 0x80047b <uxTopReadyPriority>
    152e:	98 17       	cp	r25, r24
    1530:	10 f4       	brcc	.+4      	; 0x1536 <xTaskPriorityDisinherit+0x4a>
    1532:	80 93 7b 04 	sts	0x047B, r24	; 0x80047b <uxTopReadyPriority>
    1536:	90 e0       	ldi	r25, 0x00	; 0
    1538:	9c 01       	movw	r18, r24
    153a:	22 0f       	add	r18, r18
    153c:	33 1f       	adc	r19, r19
    153e:	22 0f       	add	r18, r18
    1540:	33 1f       	adc	r19, r19
    1542:	22 0f       	add	r18, r18
    1544:	33 1f       	adc	r19, r19
    1546:	82 0f       	add	r24, r18
    1548:	93 1f       	adc	r25, r19
    154a:	b8 01       	movw	r22, r16
    154c:	8f 54       	subi	r24, 0x4F	; 79
    154e:	9b 4f       	sbci	r25, 0xFB	; 251
    1550:	0e 94 bd 01 	call	0x37a	; 0x37a <vListInsertEnd>
    1554:	81 e0       	ldi	r24, 0x01	; 1
    1556:	05 c0       	rjmp	.+10     	; 0x1562 <xTaskPriorityDisinherit+0x76>
    1558:	80 e0       	ldi	r24, 0x00	; 0
    155a:	03 c0       	rjmp	.+6      	; 0x1562 <xTaskPriorityDisinherit+0x76>
    155c:	80 e0       	ldi	r24, 0x00	; 0
    155e:	01 c0       	rjmp	.+2      	; 0x1562 <xTaskPriorityDisinherit+0x76>
    1560:	80 e0       	ldi	r24, 0x00	; 0
    1562:	df 91       	pop	r29
    1564:	cf 91       	pop	r28
    1566:	1f 91       	pop	r17
    1568:	0f 91       	pop	r16
    156a:	08 95       	ret

0000156c <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    156c:	80 91 02 05 	lds	r24, 0x0502	; 0x800502 <pxCurrentTCB>
    1570:	90 91 03 05 	lds	r25, 0x0503	; 0x800503 <pxCurrentTCB+0x1>
    1574:	89 2b       	or	r24, r25
    1576:	39 f0       	breq	.+14     	; 0x1586 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    1578:	e0 91 02 05 	lds	r30, 0x0502	; 0x800502 <pxCurrentTCB>
    157c:	f0 91 03 05 	lds	r31, 0x0503	; 0x800503 <pxCurrentTCB+0x1>
    1580:	82 a1       	ldd	r24, Z+34	; 0x22
    1582:	8f 5f       	subi	r24, 0xFF	; 255
    1584:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    1586:	80 91 02 05 	lds	r24, 0x0502	; 0x800502 <pxCurrentTCB>
    158a:	90 91 03 05 	lds	r25, 0x0503	; 0x800503 <pxCurrentTCB+0x1>
	}
    158e:	08 95       	ret

00001590 <SH_Data>:
	DIO_void_Set_pin_val(LCD_E_PORT,LCD_E_PIN,HIGH);
	_delay_ms(2);
	DIO_void_Set_pin_val(LCD_E_PORT,LCD_E_PIN,LOW);
}
static void SH_Data(u8 data)//send half data 
{
    1590:	0f 93       	push	r16
    1592:	1f 93       	push	r17
    1594:	cf 93       	push	r28
    1596:	df 93       	push	r29
    1598:	00 d0       	rcall	.+0      	; 0x159a <SH_Data+0xa>
    159a:	00 d0       	rcall	.+0      	; 0x159c <SH_Data+0xc>
    159c:	cd b7       	in	r28, 0x3d	; 61
    159e:	de b7       	in	r29, 0x3e	; 62
    15a0:	08 2f       	mov	r16, r24
	u8 LCD_PINS[4] = {LCD_D4,LCD_D5,LCD_D6,LCD_D7};
    15a2:	84 e0       	ldi	r24, 0x04	; 4
    15a4:	89 83       	std	Y+1, r24	; 0x01
    15a6:	85 e0       	ldi	r24, 0x05	; 5
    15a8:	8a 83       	std	Y+2, r24	; 0x02
    15aa:	86 e0       	ldi	r24, 0x06	; 6
    15ac:	8b 83       	std	Y+3, r24	; 0x03
    15ae:	87 e0       	ldi	r24, 0x07	; 7
    15b0:	8c 83       	std	Y+4, r24	; 0x04
	for (u8 itr = 0;itr < 4;itr++)
    15b2:	10 e0       	ldi	r17, 0x00	; 0
    15b4:	14 c0       	rjmp	.+40     	; 0x15de <SH_Data+0x4e>
	{
		DIO_void_Set_pin_val(LCD_DPORT,LCD_PINS[itr],GET_BIT(data,itr));
    15b6:	40 2f       	mov	r20, r16
    15b8:	50 e0       	ldi	r21, 0x00	; 0
    15ba:	01 2e       	mov	r0, r17
    15bc:	02 c0       	rjmp	.+4      	; 0x15c2 <SH_Data+0x32>
    15be:	55 95       	asr	r21
    15c0:	47 95       	ror	r20
    15c2:	0a 94       	dec	r0
    15c4:	e2 f7       	brpl	.-8      	; 0x15be <SH_Data+0x2e>
    15c6:	41 70       	andi	r20, 0x01	; 1
    15c8:	e1 e0       	ldi	r30, 0x01	; 1
    15ca:	f0 e0       	ldi	r31, 0x00	; 0
    15cc:	ec 0f       	add	r30, r28
    15ce:	fd 1f       	adc	r31, r29
    15d0:	e1 0f       	add	r30, r17
    15d2:	f1 1d       	adc	r31, r1
    15d4:	60 81       	ld	r22, Z
    15d6:	80 e0       	ldi	r24, 0x00	; 0
    15d8:	0e 94 49 00 	call	0x92	; 0x92 <DIO_void_Set_pin_val>
	DIO_void_Set_pin_val(LCD_E_PORT,LCD_E_PIN,LOW);
}
static void SH_Data(u8 data)//send half data 
{
	u8 LCD_PINS[4] = {LCD_D4,LCD_D5,LCD_D6,LCD_D7};
	for (u8 itr = 0;itr < 4;itr++)
    15dc:	1f 5f       	subi	r17, 0xFF	; 255
    15de:	14 30       	cpi	r17, 0x04	; 4
    15e0:	50 f3       	brcs	.-44     	; 0x15b6 <SH_Data+0x26>
	{
		DIO_void_Set_pin_val(LCD_DPORT,LCD_PINS[itr],GET_BIT(data,itr));
	}
}
    15e2:	0f 90       	pop	r0
    15e4:	0f 90       	pop	r0
    15e6:	0f 90       	pop	r0
    15e8:	0f 90       	pop	r0
    15ea:	df 91       	pop	r29
    15ec:	cf 91       	pop	r28
    15ee:	1f 91       	pop	r17
    15f0:	0f 91       	pop	r16
    15f2:	08 95       	ret

000015f4 <LCD_Send_Enable_Pulse>:
#define F_CPU 16000000ul
#include <util/delay.h>

static void LCD_Send_Enable_Pulse(void) // static to be seen by this file only
{
	DIO_void_Set_pin_val(LCD_E_PORT,LCD_E_PIN,HIGH);
    15f4:	41 e0       	ldi	r20, 0x01	; 1
    15f6:	63 e0       	ldi	r22, 0x03	; 3
    15f8:	80 e0       	ldi	r24, 0x00	; 0
    15fa:	0e 94 49 00 	call	0x92	; 0x92 <DIO_void_Set_pin_val>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    15fe:	8f e3       	ldi	r24, 0x3F	; 63
    1600:	9f e1       	ldi	r25, 0x1F	; 31
    1602:	01 97       	sbiw	r24, 0x01	; 1
    1604:	f1 f7       	brne	.-4      	; 0x1602 <LCD_Send_Enable_Pulse+0xe>
    1606:	00 c0       	rjmp	.+0      	; 0x1608 <LCD_Send_Enable_Pulse+0x14>
    1608:	00 00       	nop
	_delay_ms(2);
	DIO_void_Set_pin_val(LCD_E_PORT,LCD_E_PIN,LOW);
    160a:	40 e0       	ldi	r20, 0x00	; 0
    160c:	63 e0       	ldi	r22, 0x03	; 3
    160e:	80 e0       	ldi	r24, 0x00	; 0
    1610:	0e 94 49 00 	call	0x92	; 0x92 <DIO_void_Set_pin_val>
    1614:	08 95       	ret

00001616 <LCD_send_command>:
		//Display Clear
		LCD_send_command(0x01);		
		#endif
}
void LCD_send_command(u8 command)
{
    1616:	cf 93       	push	r28
    1618:	c8 2f       	mov	r28, r24
	/* adjust controll signals to send command */
		/*set RS --> 0 to send command*/
	DIO_void_Set_pin_val(LCD_RS_PORT,LCD_RS_PIN,LOW);
    161a:	40 e0       	ldi	r20, 0x00	; 0
    161c:	61 e0       	ldi	r22, 0x01	; 1
    161e:	80 e0       	ldi	r24, 0x00	; 0
    1620:	0e 94 49 00 	call	0x92	; 0x92 <DIO_void_Set_pin_val>
	/*set RW --> 0 to wright */
	DIO_void_Set_pin_val(LCD_RW_PORT,LCD_RW_PIN,LOW);	
    1624:	40 e0       	ldi	r20, 0x00	; 0
    1626:	62 e0       	ldi	r22, 0x02	; 2
    1628:	80 e0       	ldi	r24, 0x00	; 0
    162a:	0e 94 49 00 	call	0x92	; 0x92 <DIO_void_Set_pin_val>
	#if LCD_MODE == EIGHT_BIT_MODE
	//send enable pulse
	set_port_val(LCD_DATA_PORT,command);
	LCD_Send_Enable_Pulse();
	#elif LCD_MODE == FOUR_BIT_MODE
	SH_Data(command>>4);//SEND MOST SIGNIFICANT BIT
    162e:	8c 2f       	mov	r24, r28
    1630:	82 95       	swap	r24
    1632:	8f 70       	andi	r24, 0x0F	; 15
    1634:	0e 94 c8 0a 	call	0x1590	; 0x1590 <SH_Data>
	LCD_Send_Enable_Pulse();//SEND LEAST SIGNIFICANT BIT 
    1638:	0e 94 fa 0a 	call	0x15f4	; 0x15f4 <LCD_Send_Enable_Pulse>
	SH_Data(command);
    163c:	8c 2f       	mov	r24, r28
    163e:	0e 94 c8 0a 	call	0x1590	; 0x1590 <SH_Data>
	LCD_Send_Enable_Pulse();//SEND LEAST SIGNIFICANT BIT
    1642:	0e 94 fa 0a 	call	0x15f4	; 0x15f4 <LCD_Send_Enable_Pulse>
	#endif
	
}
    1646:	cf 91       	pop	r28
    1648:	08 95       	ret

0000164a <LCD_init>:
    164a:	2f ef       	ldi	r18, 0xFF	; 255
    164c:	83 ef       	ldi	r24, 0xF3	; 243
    164e:	91 e0       	ldi	r25, 0x01	; 1
    1650:	21 50       	subi	r18, 0x01	; 1
    1652:	80 40       	sbci	r24, 0x00	; 0
    1654:	90 40       	sbci	r25, 0x00	; 0
    1656:	e1 f7       	brne	.-8      	; 0x1650 <LCD_init+0x6>
    1658:	00 c0       	rjmp	.+0      	; 0x165a <LCD_init+0x10>
    165a:	00 00       	nop
		/*clear LCD*/
		LCD_send_command(0x01);
	#elif LCD_MODE == FOUR_BIT_MODE
		//send function set
		
		SH_Data(0b0010);
    165c:	82 e0       	ldi	r24, 0x02	; 2
    165e:	0e 94 c8 0a 	call	0x1590	; 0x1590 <SH_Data>
		LCD_Send_Enable_Pulse();
    1662:	0e 94 fa 0a 	call	0x15f4	; 0x15f4 <LCD_Send_Enable_Pulse>
		SH_Data(0b0010);
    1666:	82 e0       	ldi	r24, 0x02	; 2
    1668:	0e 94 c8 0a 	call	0x1590	; 0x1590 <SH_Data>
		LCD_Send_Enable_Pulse();
    166c:	0e 94 fa 0a 	call	0x15f4	; 0x15f4 <LCD_Send_Enable_Pulse>
		SH_Data(0b1100);
    1670:	8c e0       	ldi	r24, 0x0C	; 12
    1672:	0e 94 c8 0a 	call	0x1590	; 0x1590 <SH_Data>
		LCD_Send_Enable_Pulse();
    1676:	0e 94 fa 0a 	call	0x15f4	; 0x15f4 <LCD_Send_Enable_Pulse>
		//Display ON/OFF Controll
		LCD_send_command(0b00001100);
    167a:	8c e0       	ldi	r24, 0x0C	; 12
    167c:	0e 94 0b 0b 	call	0x1616	; 0x1616 <LCD_send_command>
		//Display Clear
		LCD_send_command(0x01);		
    1680:	81 e0       	ldi	r24, 0x01	; 1
    1682:	0e 94 0b 0b 	call	0x1616	; 0x1616 <LCD_send_command>
    1686:	08 95       	ret

00001688 <LCD_send_data>:
	LCD_Send_Enable_Pulse();//SEND LEAST SIGNIFICANT BIT
	#endif
	
}
void LCD_send_data(u8 data)
{
    1688:	cf 93       	push	r28
    168a:	c8 2f       	mov	r28, r24
	/*set RS --> 1 to send command*/
	DIO_void_Set_pin_val(LCD_RS_PORT,LCD_RS_PIN,HIGH);
    168c:	41 e0       	ldi	r20, 0x01	; 1
    168e:	61 e0       	ldi	r22, 0x01	; 1
    1690:	80 e0       	ldi	r24, 0x00	; 0
    1692:	0e 94 49 00 	call	0x92	; 0x92 <DIO_void_Set_pin_val>
	/*set RW --> 0 to write */
	DIO_void_Set_pin_val(LCD_RW_PORT,LCD_RW_PIN,LOW);
    1696:	40 e0       	ldi	r20, 0x00	; 0
    1698:	62 e0       	ldi	r22, 0x02	; 2
    169a:	80 e0       	ldi	r24, 0x00	; 0
    169c:	0e 94 49 00 	call	0x92	; 0x92 <DIO_void_Set_pin_val>
	#if LCD_MODE == EIGHT_BIT_MODE
	//send enable pulse
	set_port_val(LCD_DATA_PORT,data);
	LCD_Send_Enable_Pulse();
	#elif LCD_MODE == FOUR_BIT_MODE
	SH_Data(data>>4);//SEND MOST SIGNIFICANT BIT
    16a0:	8c 2f       	mov	r24, r28
    16a2:	82 95       	swap	r24
    16a4:	8f 70       	andi	r24, 0x0F	; 15
    16a6:	0e 94 c8 0a 	call	0x1590	; 0x1590 <SH_Data>
	LCD_Send_Enable_Pulse();//SEND LEAST SIGNIFICANT BIT
    16aa:	0e 94 fa 0a 	call	0x15f4	; 0x15f4 <LCD_Send_Enable_Pulse>
	SH_Data(data);
    16ae:	8c 2f       	mov	r24, r28
    16b0:	0e 94 c8 0a 	call	0x1590	; 0x1590 <SH_Data>
	LCD_Send_Enable_Pulse();//SEND LEAST SIGNIFICANT BIT
    16b4:	0e 94 fa 0a 	call	0x15f4	; 0x15f4 <LCD_Send_Enable_Pulse>
	#endif
}
    16b8:	cf 91       	pop	r28
    16ba:	08 95       	ret

000016bc <LCD_send_string>:

void LCD_send_string(u8 string[])
{
    16bc:	0f 93       	push	r16
    16be:	1f 93       	push	r17
    16c0:	cf 93       	push	r28
    16c2:	8c 01       	movw	r16, r24
	u8 itr = 0;
    16c4:	c0 e0       	ldi	r28, 0x00	; 0
	while(string[itr] != '\0')
    16c6:	03 c0       	rjmp	.+6      	; 0x16ce <LCD_send_string+0x12>
	{
		LCD_send_data(string[itr]);
    16c8:	0e 94 44 0b 	call	0x1688	; 0x1688 <LCD_send_data>
		itr++;
    16cc:	cf 5f       	subi	r28, 0xFF	; 255
}

void LCD_send_string(u8 string[])
{
	u8 itr = 0;
	while(string[itr] != '\0')
    16ce:	f8 01       	movw	r30, r16
    16d0:	ec 0f       	add	r30, r28
    16d2:	f1 1d       	adc	r31, r1
    16d4:	80 81       	ld	r24, Z
    16d6:	81 11       	cpse	r24, r1
    16d8:	f7 cf       	rjmp	.-18     	; 0x16c8 <LCD_send_string+0xc>
	{
		LCD_send_data(string[itr]);
		itr++;
	}
}
    16da:	cf 91       	pop	r28
    16dc:	1f 91       	pop	r17
    16de:	0f 91       	pop	r16
    16e0:	08 95       	ret

000016e2 <task1>:

void task1(){
	u8 state = 0;
	while(1)
	{	
		state = xSemaphoreTake(LCD_SEM,100);//time in waiting is 10
    16e2:	20 e0       	ldi	r18, 0x00	; 0
    16e4:	44 e6       	ldi	r20, 0x64	; 100
    16e6:	50 e0       	ldi	r21, 0x00	; 0
    16e8:	60 e0       	ldi	r22, 0x00	; 0
    16ea:	70 e0       	ldi	r23, 0x00	; 0
    16ec:	80 91 04 05 	lds	r24, 0x0504	; 0x800504 <LCD_SEM>
    16f0:	90 91 05 05 	lds	r25, 0x0505	; 0x800505 <LCD_SEM+0x1>
    16f4:	0e 94 27 05 	call	0xa4e	; 0xa4e <xQueueGenericReceive>
		//when returning 1 means it's avalable but when zero it hold in waiting for 10
		if (state == 1)
    16f8:	81 30       	cpi	r24, 0x01	; 1
    16fa:	79 f4       	brne	.+30     	; 0x171a <task1+0x38>
		{
			LCD_send_string("First");
    16fc:	87 e6       	ldi	r24, 0x67	; 103
    16fe:	90 e0       	ldi	r25, 0x00	; 0
    1700:	0e 94 5e 0b 	call	0x16bc	; 0x16bc <LCD_send_string>
			xSemaphoreGive(LCD_SEM);
    1704:	20 e0       	ldi	r18, 0x00	; 0
    1706:	40 e0       	ldi	r20, 0x00	; 0
    1708:	50 e0       	ldi	r21, 0x00	; 0
    170a:	60 e0       	ldi	r22, 0x00	; 0
    170c:	70 e0       	ldi	r23, 0x00	; 0
    170e:	80 91 04 05 	lds	r24, 0x0504	; 0x800504 <LCD_SEM>
    1712:	90 91 05 05 	lds	r25, 0x0505	; 0x800505 <LCD_SEM+0x1>
    1716:	0e 94 9d 04 	call	0x93a	; 0x93a <xQueueGenericSend>
		}
		vTaskDelay(2000);
    171a:	80 ed       	ldi	r24, 0xD0	; 208
    171c:	97 e0       	ldi	r25, 0x07	; 7
    171e:	0e 94 d5 08 	call	0x11aa	; 0x11aa <vTaskDelay>
		 // the task will be in bolckage state for 150 ticks
	}
    1722:	df cf       	rjmp	.-66     	; 0x16e2 <task1>

00001724 <task2>:

void task2(){
	u8 state =0;
	while(1)
	{
		state = xSemaphoreTake(LCD_SEM,100);//time in waiting is 10
    1724:	20 e0       	ldi	r18, 0x00	; 0
    1726:	44 e6       	ldi	r20, 0x64	; 100
    1728:	50 e0       	ldi	r21, 0x00	; 0
    172a:	60 e0       	ldi	r22, 0x00	; 0
    172c:	70 e0       	ldi	r23, 0x00	; 0
    172e:	80 91 04 05 	lds	r24, 0x0504	; 0x800504 <LCD_SEM>
    1732:	90 91 05 05 	lds	r25, 0x0505	; 0x800505 <LCD_SEM+0x1>
    1736:	0e 94 27 05 	call	0xa4e	; 0xa4e <xQueueGenericReceive>
		//when returning 1 means it's avalable but when zero it hold in waiting for 10
		if (state == 1)
    173a:	81 30       	cpi	r24, 0x01	; 1
    173c:	79 f4       	brne	.+30     	; 0x175c <task2+0x38>
		{
			LCD_send_string("Second");
    173e:	8d e6       	ldi	r24, 0x6D	; 109
    1740:	90 e0       	ldi	r25, 0x00	; 0
    1742:	0e 94 5e 0b 	call	0x16bc	; 0x16bc <LCD_send_string>
			xSemaphoreGive(LCD_SEM);
    1746:	20 e0       	ldi	r18, 0x00	; 0
    1748:	40 e0       	ldi	r20, 0x00	; 0
    174a:	50 e0       	ldi	r21, 0x00	; 0
    174c:	60 e0       	ldi	r22, 0x00	; 0
    174e:	70 e0       	ldi	r23, 0x00	; 0
    1750:	80 91 04 05 	lds	r24, 0x0504	; 0x800504 <LCD_SEM>
    1754:	90 91 05 05 	lds	r25, 0x0505	; 0x800505 <LCD_SEM+0x1>
    1758:	0e 94 9d 04 	call	0x93a	; 0x93a <xQueueGenericSend>
		}
		vTaskDelay(2000);
    175c:	80 ed       	ldi	r24, 0xD0	; 208
    175e:	97 e0       	ldi	r25, 0x07	; 7
    1760:	0e 94 d5 08 	call	0x11aa	; 0x11aa <vTaskDelay>
	}
    1764:	df cf       	rjmp	.-66     	; 0x1724 <task2>

00001766 <main>:
		LCD_send_command(0x01);
	}
}*/

int main (void)
{
    1766:	ef 92       	push	r14
    1768:	ff 92       	push	r15
    176a:	0f 93       	push	r16
	vSemaphoreCreateBinary(LCD_SEM);
    176c:	43 e0       	ldi	r20, 0x03	; 3
    176e:	60 e0       	ldi	r22, 0x00	; 0
    1770:	81 e0       	ldi	r24, 0x01	; 1
    1772:	0e 94 73 04 	call	0x8e6	; 0x8e6 <xQueueGenericCreate>
    1776:	90 93 05 05 	sts	0x0505, r25	; 0x800505 <LCD_SEM+0x1>
    177a:	80 93 04 05 	sts	0x0504, r24	; 0x800504 <LCD_SEM>
    177e:	00 97       	sbiw	r24, 0x00	; 0
    1780:	39 f0       	breq	.+14     	; 0x1790 <main+0x2a>
    1782:	20 e0       	ldi	r18, 0x00	; 0
    1784:	40 e0       	ldi	r20, 0x00	; 0
    1786:	50 e0       	ldi	r21, 0x00	; 0
    1788:	60 e0       	ldi	r22, 0x00	; 0
    178a:	70 e0       	ldi	r23, 0x00	; 0
    178c:	0e 94 9d 04 	call	0x93a	; 0x93a <xQueueGenericSend>
	set_port_dir(PORTA,OUTPUT);
    1790:	8b b3       	in	r24, 0x1b	; 27
    1792:	61 e0       	ldi	r22, 0x01	; 1
    1794:	0e 94 ba 00 	call	0x174	; 0x174 <set_port_dir>
	LCD_init();
    1798:	0e 94 25 0b 	call	0x164a	; 0x164a <LCD_init>
	xTaskCreate(task1,"task1",100,NULL,2,NULL);
    179c:	e1 2c       	mov	r14, r1
    179e:	f1 2c       	mov	r15, r1
    17a0:	02 e0       	ldi	r16, 0x02	; 2
    17a2:	20 e0       	ldi	r18, 0x00	; 0
    17a4:	30 e0       	ldi	r19, 0x00	; 0
    17a6:	44 e6       	ldi	r20, 0x64	; 100
    17a8:	50 e0       	ldi	r21, 0x00	; 0
    17aa:	64 e7       	ldi	r22, 0x74	; 116
    17ac:	70 e0       	ldi	r23, 0x00	; 0
    17ae:	81 e7       	ldi	r24, 0x71	; 113
    17b0:	9b e0       	ldi	r25, 0x0B	; 11
    17b2:	0e 94 5d 07 	call	0xeba	; 0xeba <xTaskCreate>
	xTaskCreate(task2,"task2",100,NULL,1,NULL);
    17b6:	01 e0       	ldi	r16, 0x01	; 1
    17b8:	20 e0       	ldi	r18, 0x00	; 0
    17ba:	30 e0       	ldi	r19, 0x00	; 0
    17bc:	44 e6       	ldi	r20, 0x64	; 100
    17be:	50 e0       	ldi	r21, 0x00	; 0
    17c0:	6a e7       	ldi	r22, 0x7A	; 122
    17c2:	70 e0       	ldi	r23, 0x00	; 0
    17c4:	82 e9       	ldi	r24, 0x92	; 146
    17c6:	9b e0       	ldi	r25, 0x0B	; 11
    17c8:	0e 94 5d 07 	call	0xeba	; 0xeba <xTaskCreate>
	//xTaskCreate(task3,"task3",100,NULL,1,NULL);
	vTaskStartScheduler();
    17cc:	0e 94 b1 07 	call	0xf62	; 0xf62 <vTaskStartScheduler>

	
	//while(1){} MUST BE DELETED
		
    17d0:	80 e0       	ldi	r24, 0x00	; 0
    17d2:	90 e0       	ldi	r25, 0x00	; 0
    17d4:	0f 91       	pop	r16
    17d6:	ff 90       	pop	r15
    17d8:	ef 90       	pop	r14
    17da:	08 95       	ret

000017dc <memcpy>:
    17dc:	fb 01       	movw	r30, r22
    17de:	dc 01       	movw	r26, r24
    17e0:	02 c0       	rjmp	.+4      	; 0x17e6 <memcpy+0xa>
    17e2:	01 90       	ld	r0, Z+
    17e4:	0d 92       	st	X+, r0
    17e6:	41 50       	subi	r20, 0x01	; 1
    17e8:	50 40       	sbci	r21, 0x00	; 0
    17ea:	d8 f7       	brcc	.-10     	; 0x17e2 <memcpy+0x6>
    17ec:	08 95       	ret

000017ee <_exit>:
    17ee:	f8 94       	cli

000017f0 <__stop_program>:
    17f0:	ff cf       	rjmp	.-2      	; 0x17f0 <__stop_program>
